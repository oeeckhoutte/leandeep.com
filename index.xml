<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lean Deep Tech blog</title>
    <link>https://leandeep.com/</link>
    <description>Recent content on Lean Deep Tech blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 04 May 2025 23:32:00 +0200</lastBuildDate><atom:link href="https://leandeep.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Install Nostr Rust relay without Docker</title>
      <link>https://leandeep.com/install-nostr-rust-relay-without-docker/</link>
      <pubDate>Sun, 04 May 2025 23:32:00 +0200</pubDate>
      
      <guid>https://leandeep.com/install-nostr-rust-relay-without-docker/</guid>
      <description>In this article we are going to see how to setup a Nostr relay without Docker.
Prerequisites
rust installed (else curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh) Run Nostr relay without Docker
sudo apt-get install build-essential cmake protobuf-compiler pkg-config libssl-dev git clone -q https://git.sr.ht/\~gheartsfield/nostr-rs-relay cd nostr-rs-relay cargo build -q -r RUST_LOG=warn,nostr_rs_relay=info ./target/release/nostr-rs-relay And voila the relay will listen on port 8080.</description>
    </item>
    
    <item>
      <title>Utiliser Ollama sur Ubuntu 22 via Docker et faire du LLM scraping</title>
      <link>https://leandeep.com/utiliser-ollama-sur-ubuntu-22-via-docker-et-faire-du-llm-scraping/</link>
      <pubDate>Sun, 04 May 2025 23:32:00 +0200</pubDate>
      
      <guid>https://leandeep.com/utiliser-ollama-sur-ubuntu-22-via-docker-et-faire-du-llm-scraping/</guid>
      <description>Dans cet article, nous allons voir comment utiliser Ollama sur Ubuntu 22 via Docker tout en tirant parti du GPU connecté au serveur dans le but de faire du scraping en posant des questions à son LLM auto-hébergé.
Pré-requis
nvidia-smi déjà installé Cuda installé Docker installé Installation du NVIDIA Container Toolkit
sudo apt install -y nvidia-container-toolkit sudo nvidia-ctk runtime configure --runtime=docker sudo systemctl restart docker # Vérification docker run --rm --gpus all nvidia/cuda:12.</description>
    </item>
    
    <item>
      <title>Identify path to stop docker compose</title>
      <link>https://leandeep.com/identify-path-to-stop-docker-compose/</link>
      <pubDate>Mon, 28 Apr 2025 23:40:00 +0000</pubDate>
      
      <guid>https://leandeep.com/identify-path-to-stop-docker-compose/</guid>
      <description>Very quick tip on how to identify the directory from which a docker compose command was launched (as the standard docker ps output doesn&amp;rsquo;t show it).
# Retrieve container ID docker ps docker inspect \ --format=&amp;#39;{{ index .Config.Labels &amp;#34;com.docker.compose.project.working_dir&amp;#34; }}&amp;#39; \ 0e6194178cf0 /Users/olivier/Dev/Leandeep/Rust/test_app/leptos_pg </description>
    </item>
    
    <item>
      <title>Access Raspberry Pi Camera using Python and OpenCV</title>
      <link>https://leandeep.com/access-raspberry-pi-camera-using-python-and-opencv/</link>
      <pubDate>Mon, 28 Apr 2025 21:55:00 +0200</pubDate>
      
      <guid>https://leandeep.com/access-raspberry-pi-camera-using-python-and-opencv/</guid>
      <description>In this article we are going to see how to install OpenCV on a Raspberry PI using Bookworm.
Prerequisites Install dependencies on Raspberry Pi
sudo apt update sudo apt install python3-picamera2 sudo apt install libcamera-apps sudo apt install python3-opencv Install dependencies on Macbook
pip install opencv-python numpy Code import cv2 import numpy as np import time from datetime import datetime import os # ========================== # CONSTANTS (Configuration) # ========================== BLUR_SIZE = (7, 7) # Larger → less sensitive (e.</description>
    </item>
    
    <item>
      <title>H-Bridge L298N with Raspberry Pi and Python</title>
      <link>https://leandeep.com/h-bridge-l298n-with-raspberry-pi-and-python/</link>
      <pubDate>Mon, 28 Apr 2025 21:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/h-bridge-l298n-with-raspberry-pi-and-python/</guid>
      <description>In the article we are going to see how to control a H-bridge L298N connected to a Raspberry Pi using Python.
Prerequisites Connect the bridge L298N to the raspberry pi
Connect the pin IN1 of the L298N to GPIO7 (pin 26) of the Raspberry Pi (so GPIO4). Connect the pin IN2 of the L298N to GPIO8 (pin 24) of the Raspberry Pi. Connect the pin ENA of the L298N to GPIO25 (pin 22) of the Raspberry Pi.</description>
    </item>
    
    <item>
      <title>Use an Oled display on ESP32 using Arduino</title>
      <link>https://leandeep.com/use-an-oled-display-on-esp32-using-arduino/</link>
      <pubDate>Thu, 17 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/use-an-oled-display-on-esp32-using-arduino/</guid>
      <description>In this article we are going to see how to connect and display some content on an Oled display connected via I2C on an ESP-Wroom-32. The code is written in Arduino code.
Prerequisites Install Arduino libraries:
Adafruit SSD1306 Adafruit GFX Library Connect the Oled display to the ESP32 board:
Voici le branchement I2C entre ton ESP32 et l’écran :
It is an OLED (NFP1315-61AY)
Connect VCC to 3.3V Of course connect GND to GND Connect SCL to GPIO22 Connect SDA to GPIO21 Code #include &amp;lt;Wire.</description>
    </item>
    
    <item>
      <title>Use an Oled display on ESP32 using Rust</title>
      <link>https://leandeep.com/use-an-oled-display-on-esp32-using-rust/</link>
      <pubDate>Thu, 17 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/use-an-oled-display-on-esp32-using-rust/</guid>
      <description>In this article we are going to see how to connect and display some content on an Oled display connected via I2C on an ESP-Wroom-32. The code is written in Rust.
Prerequisites Connect the Oled display to the ESP32 board:
Voici le branchement I2C entre ton ESP32 et l’écran :
It is an OLED (NFP1315-61AY)
Connect VCC to 3.3V Of course connect GND to GND Connect SCL to GPIO22 Connect SDA to GPIO21 Dependencies [dependencies] log = &amp;#34;0.</description>
    </item>
    
    <item>
      <title>Read and write file in sdcard from ESP32 and Rust</title>
      <link>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</link>
      <pubDate>Sun, 13 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</guid>
      <description>In this article we are going to see how to read a file from a SD Card in Rust using the SPI port of the ESP32.
Prerequisites cargo install esp-generate@0.3.1 esp-generate --chip esp32 sd source ~/export-esp.sh cargo build # espflash flash target/xtensa-esp32-none-elf/debug/sd --monitor Dependencies [dependencies] critical-section = &amp;#34;1.2.0&amp;#34; embassy-executor = { version = &amp;#34;0.7.0&amp;#34;, features = [&amp;#34;task-arena-size-20480&amp;#34;] } embassy-time = { version = &amp;#34;0.4.0&amp;#34;, features = [&amp;#34;generic-queue-8&amp;#34;] } esp-hal = { version = &amp;#34;1.</description>
    </item>
    
    <item>
      <title>Add a MicroSD card adapter on a ESP32 (Arduino code and OSX)</title>
      <link>https://leandeep.com/add-a-microsd-card-adapter-on-a-esp32-arduino-code-and-osx/</link>
      <pubDate>Fri, 11 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/add-a-microsd-card-adapter-on-a-esp32-arduino-code-and-osx/</guid>
      <description>Prerequisites Arduino IDE installed arduino-cli installed on OSX (using brew install arduino-cli) to ease monitoring via the command arduino-cli monitor -p /dev/ttyUSB0 -c baudrate=115200 Determine ESP32 SPI GPIO Pins. To do that you can the following code: void setup() { Serial.begin(115200); Serial.print(&amp;#34;MOSI: &amp;#34;); Serial.println(MOSI); // MOSI Pin by default Serial.print(&amp;#34;MISO: &amp;#34;); Serial.println(MISO); // MISO Pin by default Serial.print(&amp;#34;SCK: &amp;#34;); Serial.println(SCK); // SCK Pin by default Serial.print(&amp;#34;CS: &amp;#34;); Serial.println(SS); // CS Pin by default } void loop() { } Install SD library from Arduino IDE I connected VCC to 5V, GND to GND, MISO to pin 19, MOSI to pin 23, SCK to pin 18 and CS to pin 5.</description>
    </item>
    
    <item>
      <title>Get ESP32 cores count and use multithreading in Rust</title>
      <link>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</link>
      <pubDate>Tue, 08 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1.0&amp;#34; esp-idf-hal = &amp;#34;0.45.2&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } Count cores code Now update main.rs and add this code:
use esp_idf_hal::cpu; use esp_idf_svc::log::EspLogger; fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; { EspLogger::initialize_default(); log::info!(&amp;#34;Starting program...&amp;#34;); let cpu_cores = cpu::CORES; log::info!(&amp;#34;Cores count : {}&amp;#34;, cpu_cores); Ok(()) } Build and Run cargo generate --git https://github.com/esp-rs/esp-idf-template cargo cd core source ~/export-esp.sh cargo build espflash flash target/xtensa-esp32-espidf/debug/core --monitor Execute code in different threads code use core::time::Duration; use std::thread; fn main() { esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
  </channel>
</rss>
