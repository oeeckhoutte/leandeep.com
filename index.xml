<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lean Deep Tech blog</title>
    <link>https://leandeep.com/</link>
    <description>Recent content on Lean Deep Tech blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Tue, 08 Apr 2025 22:49:00 +0200</lastBuildDate><atom:link href="https://leandeep.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Get ESP32 cores count and use multithreading in Rust</title>
      <link>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</link>
      <pubDate>Tue, 08 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1.0&amp;#34; esp-idf-hal = &amp;#34;0.45.2&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } Count cores code Now update main.rs and add this code:
use esp_idf_hal::cpu; use esp_idf_svc::log::EspLogger; fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; { EspLogger::initialize_default(); log::info!(&amp;#34;Starting program...&amp;#34;); let cpu_cores = cpu::CORES; log::info!(&amp;#34;Cores count : {}&amp;#34;, cpu_cores); Ok(()) } Build and Run cargo generate --git https://github.com/esp-rs/esp-idf-template cargo cd core source ~/export-esp.sh cargo build espflash flash target/xtensa-esp32-espidf/debug/core --monitor Execute code in different threads code use core::time::Duration; use std::thread; fn main() { esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
    <item>
      <title>Scan Wifi networks on ESP32 using Rust</title>
      <link>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</link>
      <pubDate>Tue, 08 Apr 2025 20:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</guid>
      <description>In this article we are going to see how to scan Wifi networks around you.
The crates used are the following ones:
[dependencies] log = &amp;#34;0.4&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; use esp_idf_hal::prelude::*; use esp_idf_svc::eventloop::EspSystemEventLoop; use esp_idf_svc::nvs::EspDefaultNvsPartition; use esp_idf_svc::sys::EspError; use esp_idf_svc::wifi::{AuthMethod, BlockingWifi, ClientConfiguration, Configuration, EspWifi}; use std::thread; use std::time::Duration; fn main() -&amp;gt; Result&amp;lt;(), EspError&amp;gt; { esp_idf_svc::sys::link_patches(); esp_idf_svc::log::EspLogger::initialize_default(); log::set_max_level(log::LevelFilter::Info); log::info!(&amp;#34;Program started!&amp;#34;); // Init needed components let peripherals = Peripherals::take().</description>
    </item>
    
    <item>
      <title>Get GPS coordinates on ESP32 using basic Arduino code</title>
      <link>https://leandeep.com/get-gps-coordinates-on-esp32-using-basic-arduino-code/</link>
      <pubDate>Wed, 02 Apr 2025 20:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/get-gps-coordinates-on-esp32-using-basic-arduino-code/</guid>
      <description>In this article we are going to see how to retrieve NMEA sentences from a GPS module NEO-6M connected to an ESP32.
Connect the NEO-6M GPS module to the ESP32 Then create an Arduino program and deploy it to the ESP-wroom-32.
arduino-cli sketch new arduino-gps cd arduino-gps/ Edit the arduino-gps.ino file and add the following content:
#define RXD2 16 #define TXD2 17 #define GPS_BAUD 9600 // Create an instance of the HardwareSerial class for Serial 2 HardwareSerial gpsSerial(2); void setup(){ // Serial Monitor Serial.</description>
    </item>
    
    <item>
      <title>Get GPS coordinates on ESP32 using Rust</title>
      <link>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</link>
      <pubDate>Wed, 02 Apr 2025 20:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</guid>
      <description>In this article we are going to see how to retrieve NMEA sentences from a GPS module NEO-6M connected to an ESP32.
Connect the NEO-6M GPS module to the ESP32 Dependencies:
esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; use esp_idf_hal::peripherals::Peripherals; use esp_idf_hal::prelude::*; use esp_idf_hal::uart::*; use esp_idf_svc::hal::uart::config::DataBits; use esp_idf_svc::hal::uart::config::StopBits; fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; { // Lien des patches ESP-IDF esp_idf_svc::sys::link_patches(); // Configuration du logger esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
    <item>
      <title>Connect ESP32 to wifi network using Rust</title>
      <link>https://leandeep.com/connect-esp32-to-wifi-network-using-rust/</link>
      <pubDate>Fri, 28 Mar 2025 15:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/connect-esp32-to-wifi-network-using-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1&amp;#34; embedded-svc = { version = &amp;#34;0.28&amp;#34;, default-features = false } esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } Code Now update main.rs and add this code:
use core::convert::TryInto; use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration}; use esp_idf_svc::hal::prelude::Peripherals; use esp_idf_svc::log::EspLogger; use esp_idf_svc::wifi::{BlockingWifi, EspWifi}; use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition}; use log::info; const SSID: &amp;amp;str = &amp;#34;SSID&amp;#34;; const PASSWORD: &amp;amp;str = &amp;#34;password&amp;#34;; fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; { esp_idf_svc::sys::link_patches(); EspLogger::initialize_default(); let peripherals = Peripherals::take()?</description>
    </item>
    
    <item>
      <title>Power on a PC when a button is pushed on an ESP32 using Rust</title>
      <link>https://leandeep.com/power-on-a-pc-when-a-button-is-pushed-on-an-esp32-using-rust/</link>
      <pubDate>Fri, 28 Mar 2025 15:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/power-on-a-pc-when-a-button-is-pushed-on-an-esp32-using-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1&amp;#34; embedded-svc = { version = &amp;#34;0.28&amp;#34;, default-features = false } esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; Code Now update main.rs and add this code:
use core::convert::TryInto; use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration}; //use esp_idf_svc::hal::prelude::Peripherals; use esp_idf_svc::log::EspLogger; use esp_idf_svc::wifi::{BlockingWifi, EspWifi}; use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition}; use log::info; use std::net::{UdpSocket, Ipv4Addr, SocketAddrV4}; use std::time::Duration; use esp_idf_hal::delay::FreeRtos; use esp_idf_hal::gpio::PinDriver; use esp_idf_hal::peripherals::Peripherals; const SSID: &amp;amp;str = &amp;#34;.</description>
    </item>
    
    <item>
      <title>Switch on a LED using Rust when a button is pushed on ESP32</title>
      <link>https://leandeep.com/switch-on-a-led-using-rust-when-a-button-is-pushed-on-esp32/</link>
      <pubDate>Fri, 28 Mar 2025 14:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/switch-on-a-led-using-rust-when-a-button-is-pushed-on-esp32/</guid>
      <description>The idea of this article is to explore how to switch on a LED when a push button is pressed. Once it is release the LED is switched off.
Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; Code Now update main.rs and add this code:
use esp_idf_hal::delay::FreeRtos; use esp_idf_hal::gpio::PinDriver; use esp_idf_hal::peripherals::Peripherals; fn main() -&amp;gt; ! { esp_idf_svc::sys::link_patches(); // Bind the log crate to the ESP Logging facilities esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
    <item>
      <title>Make onboard LED blink using Rust on ESP32</title>
      <link>https://leandeep.com/make-onboard-led-blink-using-rust-on-esp32/</link>
      <pubDate>Fri, 28 Mar 2025 11:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/make-onboard-led-blink-using-rust-on-esp32/</guid>
      <description>AI tools are awesome. Lately, I&amp;rsquo;ve been wondering if they could replace us developers, but actually no it&amp;rsquo;s impossible because you always have issues. However, it&amp;rsquo;s crazy how much they boost my productivity. I now do my research directly on LLMs and get answers much faster than if I had searched on Google myself. It&amp;rsquo;s fantastic!
In this new article, we will explore how to make an onboard LED blink on an ESP32 using Rust.</description>
    </item>
    
    <item>
      <title>Installer code server sur Ubuntu 22</title>
      <link>https://leandeep.com/installer-code-server-sur-ubuntu-22/</link>
      <pubDate>Fri, 28 Mar 2025 10:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/installer-code-server-sur-ubuntu-22/</guid>
      <description>Dans cet article très court, nous allons voir comment installer code-server sur Ubuntu 22. Code-server est un vscode en remote.
Installation Rendez-vous sur https://github.com/coder/code-server/releases pour sélectionner la version que vous souhaitez installer.
export VERSION=4.98.2 curl -fOL https://github.com/coder/code-server/releases/download/v$VERSION/code-server-$VERSION-amd64.rpm sudo rpm -i code-server-$VERSION-amd64.rpm sudo systemctl enable --now code-server@$USER Configuration Editer le fichier de config ~/.config/code-server/config.yaml pour activer l&amp;rsquo;utilisation d&amp;rsquo;un certificat HTTPS (même en local) et récupérez le mot de passe d&amp;rsquo;accès à votre instance code-server.</description>
    </item>
    
    <item>
      <title>Installer Arduino cli Ubuntu 22</title>
      <link>https://leandeep.com/installer-arduino-cli-ubuntu-22/</link>
      <pubDate>Fri, 28 Mar 2025 09:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/installer-arduino-cli-ubuntu-22/</guid>
      <description>Dans ce nouvel article très court, nous allons voir comment créer un projet Arduino, le compiler et le déployer sur un ESP en ligne de commande.
Installation mkdir -p ~/local/bin curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | BINDIR=~/local/bin sh echo &amp;#39;export PATH=&amp;#34;$HOME/local/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bashrc source ~/.bashrc arduino-cli version arduino-cli core update-index arduino-cli core install esp32:esp32 arduino-cli sketch new mon_projet_esp32_arduino arduino-cli compile --fqbn esp32:esp32:esp32 mon_projet_esp32_arduino arduino-cli upload -p /dev/ttyUSB0 --fqbn esp32:esp32:esp32 mon_projet_esp32_arduino Test Ouvrir le projet Arduino mon_projet_esp32_arduino et modifier le fichier .</description>
    </item>
    
  </channel>
</rss>
