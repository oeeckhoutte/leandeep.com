<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lean Deep Tech blog</title>
    <link>https://leandeep.com/</link>
    <description>Recent content on Lean Deep Tech blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Fri, 27 Jan 2023 10:49:00 +0200</lastBuildDate><atom:link href="https://leandeep.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Créer un dataset avec les données Binance OHLCV pour réaliser des backtests</title>
      <link>https://leandeep.com/cr%C3%A9er-un-dataset-avec-les-donn%C3%A9es-binance-ohlcv-pour-r%C3%A9aliser-des-backtests/</link>
      <pubDate>Fri, 27 Jan 2023 10:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/cr%C3%A9er-un-dataset-avec-les-donn%C3%A9es-binance-ohlcv-pour-r%C3%A9aliser-des-backtests/</guid>
      <description>Sans utiliser la librairie CCTX dont j&amp;rsquo;ai parlé dans l&amp;rsquo;article, voici comment récupérer directement les données OHLCV depuis l&amp;rsquo;API de Binance:
import requests import datetime import pandas as pd import numpy as np start_date = &amp;#34;2022-01-01&amp;#34; end_date = &amp;#34;2022-01-31&amp;#34; interval = &amp;#34;1m&amp;#34; symbol = &amp;#34;BTCUSDT&amp;#34; def get_binance_data( ticker: str, interval: str = &amp;#34;4h&amp;#34;, limit: int = 500, start: str = &amp;#34;2018-01-01 00:00:00&amp;#34;, ) -&amp;gt; pd.DataFrame: &amp;#34;&amp;#34;&amp;#34;Get X (limit) OHLCV entries from Binance&amp;#34;&amp;#34;&amp;#34; columns = [ &amp;#34;open_time&amp;#34;, &amp;#34;open&amp;#34;, &amp;#34;high&amp;#34;, &amp;#34;low&amp;#34;, &amp;#34;close&amp;#34;, &amp;#34;volume&amp;#34;, &amp;#34;close_time&amp;#34;, &amp;#34;qav&amp;#34;, &amp;#34;num_trades&amp;#34;, &amp;#34;taker_base_vol&amp;#34;, &amp;#34;taker_quote_vol&amp;#34;, &amp;#34;ignore&amp;#34;, ] start = int(datetime.</description>
    </item>
    
    <item>
      <title>Installer InfluxDB 2 sur Debian 11</title>
      <link>https://leandeep.com/installer-influxdb-2-sur-debian-11/</link>
      <pubDate>Fri, 27 Jan 2023 09:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/installer-influxdb-2-sur-debian-11/</guid>
      <description>Dans cet article très court, nous allons voir comment installer InfluxDB 2 via Docker sur Debian 11.
Installation de Docker apt install docker.io curl -L &amp;#34;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&amp;#34; -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose On active ensuite le service:
systemctl enable docker systemctl start docker Installation d&amp;rsquo;InfluxDB Une fois Docker et docker-compose installés, on peut créer nos fichiers docker-compose.yml, influx.env et telegraf.conf.
Contenu du fichier docker-compose.yml:
version: &amp;#39;3&amp;#39; services: influxdb: image: influxdb:2.</description>
    </item>
    
    <item>
      <title>Erigon full node sur Debian 11</title>
      <link>https://leandeep.com/erigon-full-node-sur-debian-11/</link>
      <pubDate>Fri, 27 Jan 2023 07:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/erigon-full-node-sur-debian-11/</guid>
      <description>Installation des pré-requis Installation de go
wget https://dl.google.com/go/go1.19.5.linux-amd64.tar.gz tar -C /usr/local -xzf go1.19.5.linux-amd64.tar.gz Editer /root/bashrc et ajouter les commandes suivantes
export PATH=$PATH:/usr/local/go/bin export GOPATH=&amp;#34;${HOME}/.go/bin&amp;#34; export PATH=$GOPATH:$PATH Autres outils et consensus mechanism
# Prevent Debian sleep or hibernation systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target apt vim curl install git make supervisor build-essential software-properties-common net-tools jq mkdir -p ethereum/consensus/prysm cd $_ curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh &amp;amp;&amp;amp; chmod +x prysm.sh Ouvrir le fichier /root/.</description>
    </item>
    
    <item>
      <title>Utiliser des binaires NodeJS avec nvm et Xcode</title>
      <link>https://leandeep.com/utiliser-des-binaires-nodejs-avec-nvm-et-xcode/</link>
      <pubDate>Sun, 15 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/utiliser-des-binaires-nodejs-avec-nvm-et-xcode/</guid>
      <description>Lorsqu&amp;rsquo;on utilise un binaire NodeJS sur xcode mais qu&amp;rsquo;on n&amp;rsquo;utilise pas NodeJS &amp;ldquo;classiquement&amp;rdquo; installé avec brew ou curl, on obtient la magnifiquer error &amp;ldquo;command not found&amp;rdquo; lorsque que Xcode build
Correctif Pour remédier à ce problème, il suffit d&amp;rsquo;ajouter le script suivant dans la section build phase de son projet Xcode, avant bien sûr que la commande node soit exécutée.
if [[ -s &amp;#34;$HOME/.nvm/nvm.sh&amp;#34; ]]; then . &amp;#34;$HOME/.nvm/nvm.sh&amp;#34; elif [[ -x &amp;#34;$(command -v brew)&amp;#34; &amp;amp;&amp;amp; -s &amp;#34;$(brew --prefix nvm)/nvm.</description>
    </item>
    
    <item>
      <title>Retourner un dataframe OHLCV des tickers Binance à partir de CCTX</title>
      <link>https://leandeep.com/retourner-un-dataframe-ohlcv-des-tickers-binance-%C3%A0-partir-de-cctx/</link>
      <pubDate>Sat, 14 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/retourner-un-dataframe-ohlcv-des-tickers-binance-%C3%A0-partir-de-cctx/</guid>
      <description>Petit tip du jour de minutes. Voici comment convertir les données OHLCV de Binance obtenues grâce à CCTX en dataframe.
import ccxt import calendar from datetime import datetime import pandas as pd import numpy as np from typing import List binance = ccxt.binance() def min_ohlcv(dt: datetime, pair: str, limit: int) -&amp;gt; list: # UTC native object since = calendar.timegm(dt.utctimetuple()) * 1000 ohlcv1 = binance.fetch_ohlcv( symbol=pair, timeframe=&amp;#34;1m&amp;#34;, since=since, limit=limit ) ohlcv2 = binance.</description>
    </item>
    
    <item>
      <title>Terraform REPL</title>
      <link>https://leandeep.com/terraform-repl/</link>
      <pubDate>Mon, 09 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/terraform-repl/</guid>
      <description>Dans cet article, nous allons voir comment tester son code Terraform façon REPL. L&amp;rsquo;idée c&amp;rsquo;est de pouvoir rapidement dégainer un REPL pour pouvoir tester la bonne syntaxe de son code lorsqu&amp;rsquo;on veut le faire évoluer.
J&amp;rsquo;ai vu qu&amp;rsquo;il y avait des projets non officiel open source sur Github comme celui-ci avec apparemment un vrai REPL mais je n&amp;rsquo;ai pas eu le temps de l&amp;rsquo;analyser et de vérifier qu&amp;rsquo;il n&amp;rsquo;y avait pas de bug et surtout de faille de sécurité.</description>
    </item>
    
    <item>
      <title>Ajouter un prefix sur les noms des fichiers d&#39;un répertoire</title>
      <link>https://leandeep.com/ajouter-un-prefix-sur-les-noms-des-fichiers-dun-r%C3%A9pertoire/</link>
      <pubDate>Sat, 07 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/ajouter-un-prefix-sur-les-noms-des-fichiers-dun-r%C3%A9pertoire/</guid>
      <description>Petit tip du jour de 5 secondes pour ajouter un prefix devant tous les fichiers d&amp;rsquo;un répertoire:
for f in * ; do mv &amp;#34;$f&amp;#34; Prefix_&amp;#34;$f&amp;#34; ; done </description>
    </item>
    
    <item>
      <title>Enregistrer vos playlists Youtube en mp3 ou mp4 via le CLI</title>
      <link>https://leandeep.com/enregistrer-vos-playlists-youtube-en-mp3-ou-mp4-via-le-cli/</link>
      <pubDate>Sat, 07 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/enregistrer-vos-playlists-youtube-en-mp3-ou-mp4-via-le-cli/</guid>
      <description>Petit tip du jour de 25 secondes: pour enregistrer automatiquement via cli vos playlists Youtube en MP3, il vous suffit d&amp;rsquo;utiliser le package Python yt-dlp.
pip install yt-dlp # Enregistrement mp3 yt-dlp -f &amp;#39;ba&amp;#39; -x --audio-format mp3 lien_vers_votre_playlist # Enregistrement mp4 # Best video quality yt-dlp lien_vers_votre_playlist -f &amp;#34;bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best&amp;#34; # Enregistrement mp4 # Worst video quality mais high quality audio yt-dlp lien_vers_votre_playlist -f &amp;#34;worstvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best&amp;#34; </description>
    </item>
    
    <item>
      <title>Afficher les 500 dernières bougies d&#39;une paire crypto de Binance</title>
      <link>https://leandeep.com/afficher-les-500-derni%C3%A8res-bougies-dune-paire-crypto-de-binance/</link>
      <pubDate>Thu, 05 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/afficher-les-500-derni%C3%A8res-bougies-dune-paire-crypto-de-binance/</guid>
      <description>Petit tip du jour. Voici comment afficher, en moins 2 minutes, l&amp;rsquo;évolution du cours d&amp;rsquo;une paire crypto présente sur Binance.
Installer les packages cctx et plotly puis créer un fichier contenant le code suivant:
import ccxt from datetime import datetime import plotly.graph_objects as go def run(): binance = ccxt.binance() trading_pair = &amp;#34;BTC/USDT&amp;#34; candles = binance.fetch_ohlcv(trading_pair, &amp;#34;1d&amp;#34;) dates = [] open_data = [] high_data = [] low_data = [] close_data = [] for candle in candles: dates.</description>
    </item>
    
    <item>
      <title>Cointégration vs Corrélation en trading</title>
      <link>https://leandeep.com/coint%C3%A9gration-vs-corr%C3%A9lation-en-trading/</link>
      <pubDate>Tue, 03 Jan 2023 07:00:00 +0200</pubDate>
      
      <guid>https://leandeep.com/coint%C3%A9gration-vs-corr%C3%A9lation-en-trading/</guid>
      <description>Introduction Miser sur la corrélation entre différents assets pour faire du pair trading est une mauvaise idée. Il vaut mieux miser sur la cointégration.
Corrélation vs Cointégration La cointégration est une relation statistique entre deux variables qui évoluent de manière similaire à long terme. Cela signifie que si l&amp;rsquo;une des variables change, l&amp;rsquo;autre suivra également cette tendance sur une période de temps prolongée.
La corrélation, en revanche, mesure simplement la relation entre deux variables à un moment donné.</description>
    </item>
    
  </channel>
</rss>
