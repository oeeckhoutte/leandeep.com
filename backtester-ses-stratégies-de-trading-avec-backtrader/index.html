<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
  content="Olivier Eeckhoutte">
<meta name="description"
  content="Voici un exemple de code Python permettant de backtester une strat√©gie (ici j&amp;rsquo;en ai cr√©√© une compl√®tement inutile mais cela permet d&amp;rsquo;illustrer mon propose).
Pr√©-requis
pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2 import math import pandas as pd import backtrader as bt import ccxt # Charger les donn√©es historiques depuis Binance exchange = ccxt.binance( { &amp;#34;apiKey&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;secret&amp;#34;: &amp;#34;&amp;#34;, } ) symbol = &amp;#34;ETH/USDT&amp;#34; timeframe = &amp;#34;1h&amp;#34; ohlcv = exchange.fetch_ohlcv(symbol, timeframe) df = pd." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<script>
  
  
  if (!(window.location.host.startsWith("127.0.0.1")) && !(window.location.host.startsWith("localhost"))) {
    if (window.location.protocol != "https:") {
      console.log("Redirecting to https...")
      window.location.protocol = "https";
    }
  }
</script>


<link rel="canonical" href="https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/" />



<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
  #app {
    display: none;
    border-radius: 10px;
    box-shadow: 2px 5px 12px -1px rgba(0, 0, 0, 0.56);
    padding: 20px;
    background-color: white;
    max-width: 500px;
    margin: 15px auto;
    text-align: center;
    min-height: 500px;
  }

  #app input {
    margin: 0 auto;
    float: none;
    width: 100%;
    max-width: 300px;
    padding: 5px 10px;
    border: 2px solid black;
  }

  #app ul {
    margin: 0;
    padding: 0;
  }

  #app li {
    text-align: left;
    padding: 5px 10px;
    width: 100%;
    max-width: 280px;
    margin: 1px auto;
    background-color: white;
    border: 1px solid black;
    list-style: none;
  }
</style>




<title>
  
  Backtester ses strat√©gies de trading avec Backtrader :: Lean Deep Tech blog 
  
</title>



<link href="//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
  type="text/css">



<link rel="stylesheet" href="https://leandeep.com/main.min.44eaa49e743eabd51724579f1d2ece0dac6f56215301d6961ca74092199d4a05.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://leandeep.com/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://leandeep.com/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://leandeep.com/favicon-16x16.png">
    <link rel="manifest" href="https://leandeep.com/site.webmanifest">
    <link rel="mask-icon" href="https://leandeep.com/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://leandeep.com/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="Backtester ses strat√©gies de trading avec Backtrader">
<meta itemprop="description" content="Voici un exemple de code Python permettant de backtester une strat√©gie (ici j&rsquo;en ai cr√©√© une compl√®tement inutile mais cela permet d&rsquo;illustrer mon propose).
Pr√©-requis
pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2 import math import pandas as pd import backtrader as bt import ccxt # Charger les donn√©es historiques depuis Binance exchange = ccxt.binance( { &#34;apiKey&#34;: &#34;&#34;, &#34;secret&#34;: &#34;&#34;, } ) symbol = &#34;ETH/USDT&#34; timeframe = &#34;1h&#34; ohlcv = exchange.fetch_ohlcv(symbol, timeframe) df = pd."><meta itemprop="datePublished" content="2024-02-02T18:10:00+00:00" />
<meta itemprop="dateModified" content="2024-02-02T18:10:00+00:00" />
<meta itemprop="wordCount" content="1614"><meta itemprop="image" content="https://leandeep.com"/>
<meta itemprop="keywords" content="Python,Backtesting,Backtrader,Trading,AlgoTrading," /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://leandeep.com"/>

<meta name="twitter:title" content="Backtester ses strat√©gies de trading avec Backtrader"/>
<meta name="twitter:description" content="Voici un exemple de code Python permettant de backtester une strat√©gie (ici j&rsquo;en ai cr√©√© une compl√®tement inutile mais cela permet d&rsquo;illustrer mon propose).
Pr√©-requis
pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2 import math import pandas as pd import backtrader as bt import ccxt # Charger les donn√©es historiques depuis Binance exchange = ccxt.binance( { &#34;apiKey&#34;: &#34;&#34;, &#34;secret&#34;: &#34;&#34;, } ) symbol = &#34;ETH/USDT&#34; timeframe = &#34;1h&#34; ohlcv = exchange.fetch_ohlcv(symbol, timeframe) df = pd."/>





<meta property="article:published_time" content="2024-02-02 18:10:00 &#43;0000 UTC" />







    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://leandeep.com/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/leandeep</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://leandeep.com/events/">Featured Articles</a></li><li><a href="https://leandeep.com/posts/">All Articles</a></li><li><a href="https://leandeep.com/about/">About</a></li><li><a href="https://leandeep.com/finance/">Finance</a></li><li><a href="https://leandeep.com/notebooks/">ML Notebooks</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>

            <div class="content">
                
    <main class="post">

        <div class="post-info">
            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>8 minutes

            

            </p>
        </div>

        <article>
            <h1 class="post-title">
                <a href="https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/">Backtester ses strat√©gies de trading avec Backtrader</a>
            </h1>

            

            <div class="post-content">
                <p>Voici un exemple de code Python permettant de backtester une strat√©gie (ici j&rsquo;en ai cr√©√© une compl√®tement inutile mais cela permet d&rsquo;illustrer mon propose).</p>
<p><br/>
<strong>Pr√©-requis</strong></p>
<pre tabindex="0"><code>pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2
</code></pre><br/>
<pre tabindex="0"><code>import math
import pandas as pd
import backtrader as bt
import ccxt

# Charger les donn√©es historiques depuis Binance
exchange = ccxt.binance(
    {
        &#34;apiKey&#34;: &#34;&#34;,
        &#34;secret&#34;: &#34;&#34;,
    }
)

symbol = &#34;ETH/USDT&#34;
timeframe = &#34;1h&#34;

ohlcv = exchange.fetch_ohlcv(symbol, timeframe)
df = pd.DataFrame(
    ohlcv, columns=[&#34;timestamp&#34;, &#34;open&#34;, &#34;high&#34;, &#34;low&#34;, &#34;close&#34;, &#34;volume&#34;]
)
df[&#34;timestamp&#34;] = pd.to_datetime(df[&#34;timestamp&#34;], unit=&#34;ms&#34;)
df.set_index(&#34;timestamp&#34;, inplace=True)


# D√©finir la strat√©gie
class MovingAverageCrossStrategy(bt.Strategy):
    params = (
        (&#34;short_period&#34;, 20),
        (&#34;long_period&#34;, 50),
    )

    def __init__(self):
        self.short_ma = bt.indicators.SimpleMovingAverage(
            self.data.close, period=self.params.short_period
        )
        self.long_ma = bt.indicators.SimpleMovingAverage(
            self.data.close, period=self.params.long_period
        )
        self.crossover = bt.indicators.CrossOver(self.short_ma, self.long_ma)

    def next(self):
        if self.crossover &gt; 0:
            # Signal d&#39;achat
            self.buy()
        elif self.crossover &lt; 0:
            # Signal de vente
            self.sell()


# Convertir les donn√©es pandas en format compr√©hensible par backtrader
data = bt.feeds.PandasData(dataname=df)

# Configurer le cerveau du backtest
cerebro = bt.Cerebro()
cerebro.adddata(data)
cerebro.addstrategy(MovingAverageCrossStrategy)

# Ajouter un observer pour afficher les gains/pertes
cerebro.addobserver(bt.observers.Value)

# Param√®tres du backtest
start_date = pd.to_datetime(&#34;2022-01-01&#34;)
end_date = pd.to_datetime(&#34;2022-12-31&#34;)
cerebro.run(stdstats=False, tradehistory=True, fromdate=start_date, todate=end_date)

# Afficher les gains/pertes
final_portfolio_value = cerebro.broker.getvalue()
print(f&#34;Capital final: {final_portfolio_value} USDT&#34;)
cerebro.plot()
</code></pre><p><img src="https://leandeep.com/images/backtrader.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie Mean Reversion:</strong></p>
<pre tabindex="0"><code># D√©finir la strat√©gie
class MeanReversionStrategy(bt.Strategy):
    params = (
        (&#39;rsi_period&#39;, 14),
        (&#39;rsi_overbought&#39;, 70),
        (&#39;rsi_oversold&#39;, 30),
        (&#39;bbands_period&#39;, 20),
        (&#39;bbands_dev&#39;, 2),
    )

    def __init__(self):
        self.rsi = bt.indicators.RelativeStrengthIndex(period=self.params.rsi_period)
        self.bbands = bt.indicators.BollingerBands(period=self.params.bbands_period, devfactor=self.params.bbands_dev)

    def next(self):
        if self.rsi &lt; self.params.rsi_oversold and self.data.close &lt; self.bbands.lines.bot:
            # Conditions d&#39;achat
            self.buy()

        elif self.rsi &gt; self.params.rsi_overbought and self.data.close &gt; self.bbands.lines.top:
            # Conditions de vente
            self.sell()
</code></pre><p>Dans cette strat√©gie, des signaux d&rsquo;achat sont g√©n√©r√©s lorsque le RSI est en zone de survente et que le prix est en dessous de la bande inf√©rieure de Bollinger. Des signaux de vente sont g√©n√©r√©s lorsque le RSI est en zone de surachat et que le prix est au-dessus de la bande sup√©rieure de Bollinger.</p>
<p><img src="https://leandeep.com/images/backtrader2.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie Ichimoku:</strong></p>
<pre tabindex="0"><code>class Ichimoku(bt.Strategy):

    def __init__(self):

        self.ichimoku = bt.indicators.Ichimoku()
   
    def next(self):

         if not self.position and self.ichimoku.lines.senkou_span_a &gt; self.ichimoku.lines.senkou_span_b: 
            amount_to_invest = (0.95 * self.broker.cash)
            self.size = math.floor(amount_to_invest / self.data.close)

            print(&#34;Buy {} shares at {}&#34;.format(self.size, self.data.close[0]))
            self.buy(size=self.size)

         if self.position and self.ichimoku.lines.senkou_span_a &lt; self.ichimoku.lines.senkou_span_b:
            print(&#34;Sell {} shares at {}&#34;.format(self.size, self.data.close[0]))
            self.close()
</code></pre><p>Aucun param√®tre sp√©cifique n&rsquo;est fourni √† l&rsquo;indicateur, ce qui signifie que les valeurs par d√©faut des p√©riodes Ichimoku sont utilis√©es (9, 26, 52).</p>
<p>La fonction next est appel√©e √† chaque barre de prix. La strat√©gie v√©rifie d&rsquo;abord si elle n&rsquo;a pas de position (not self.position) et si la ligne Senkou Span A est au-dessus de la ligne Senkou Span B. Si ces conditions sont remplies, cela signifie que la tendance est √† la hausse, et un signal d&rsquo;achat est g√©n√©r√©.
En cas de signal d&rsquo;achat, la strat√©gie calcule la quantit√© d&rsquo;actions √† acheter en fonction de 95% du capital disponible (0.95 * self.broker.cash) et ach√®te ces actions en utilisant la fonction self.buy.
Ensuite, la strat√©gie v√©rifie si elle a d√©j√† une position (self.position) et si la ligne Senkou Span A est en dessous de la ligne Senkou Span B. Si ces conditions sont remplies, cela signifie que la tendance est √† la baisse, et un signal de vente est g√©n√©r√©.
En cas de signal de vente, la strat√©gie ferme la position en utilisant la fonction self.close.</p>
<p><img src="https://leandeep.com/images/backtrader3.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie Aroon:</strong></p>
<p>La strat√©gie Aroon est bas√©e sur l&rsquo;utilisation des indicateurs Aroon, qui sont con√ßus pour mesurer la force de la tendance et identifier les p√©riodes de consolidation ou de retournement de tendance sur un march√© financier. Les indicateurs Aroon se composent de deux lignes principales : Aroon Up et Aroon Down.</p>
<p>Aroon Up (Aroon Haut) : Mesure le nombre de p√©riodes √©coul√©es depuis le plus haut r√©cent.</p>
<p>Aroon Down (Aroon Bas) : Mesure le nombre de p√©riodes √©coul√©es depuis le plus bas r√©cent.</p>
<p>La strat√©gie Aroon utilise ces deux indicateurs pour g√©n√©rer des signaux de trading. Voici comment interpr√©ter les signaux Aroon dans une strat√©gie de base :</p>
<p>Signal d&rsquo;Achat (Aroon Up fort) : Lorsque l&rsquo;Aroon Up est √©lev√©, cela indique que la tendance √† la hausse est forte. Un signal d&rsquo;achat est g√©n√©r√© lorsque l&rsquo;Aroon Up traverse √† la hausse l&rsquo;Aroon Down.</p>
<p>Signal de Vente (Aroon Down fort) : Lorsque l&rsquo;Aroon Down est √©lev√©, cela indique que la tendance √† la baisse est forte. Un signal de vente est g√©n√©r√© lorsque l&rsquo;Aroon Down traverse √† la hausse l&rsquo;Aroon Up.</p>
<p>P√©riode de Consolidation (Aroon Up et Aroon Down faibles) : Si les deux Aroon Up et Aroon Down sont faibles, cela indique une p√©riode de consolidation o√π le march√© ne montre pas de tendance claire. Certains traders choisissent d&rsquo;√©viter de prendre des positions pendant ces p√©riodes.</p>
<pre tabindex="0"><code>class AroonStrategy(bt.Strategy):

    params = ((&#34;upperband&#34;, 99), (&#34;lowerband&#34;, -99), (&#34;order_percentage&#34;, 0.95))

    def __init__(self):
        self.Aroon = bt.indicators.AroonOscillator(self.data, period=14)

    def next(self):
        if not self.position and self.Aroon &lt; self.params.lowerband:
            amount_to_invest = self.params.order_percentage * self.broker.cash
            self.size = math.floor(amount_to_invest / self.data.close)

            print(&#34;Buy {} shares  at {}&#34;.format(self.size, self.data.close[0]))
            self.buy(size=self.size)

        if self.position and self.Aroon &gt; self.params.upperband:
            print(&#34;Sell {} shares  at {}&#34;.format(self.size, self.data.close[0]))
            self.close()
</code></pre><p><img src="https://leandeep.com/images/backtrader4.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie Buy and Hold:</strong></p>
<pre tabindex="0"><code>class BuyHoldStrategy(bt.Strategy):

    def next(self):
        if self.position.size == 0:
            amount_to_invest = 0.95 * self.broker.getcash()
            size = math.floor(amount_to_invest / self.data)
            print(&#34;Buy {} shares at {}&#34;.format(size, self.data.close[0]))
            self.buy(size=size)
</code></pre><br/>
<p><strong>Strat√©gie Golden cross:</strong></p>
<p>La strat√©gie Golden Cross est une approche de trading bas√©e sur l&rsquo;identification d&rsquo;un signal lorsque deux moyennes mobiles se croisent √† la hausse. C&rsquo;est une strat√©gie populaire dans l&rsquo;analyse technique et est souvent utilis√©e pour rep√©rer des changements potentiels dans la tendance d&rsquo;un actif financier.</p>
<p>Voici comment fonctionne la strat√©gie Golden Cross:</p>
<ol>
<li>Moyenne Mobile √† Court Terme (Short-Term Moving Average):</li>
</ol>
<p>Une moyenne mobile √† court terme est calcul√©e en prenant la moyenne des prix de cl√¥ture sur une p√©riode relativement courte.
Cette moyenne mobile r√©agit plus rapidement aux fluctuations des prix.</p>
<br/>
<ol start="2">
<li>Moyenne Mobile √† Long Terme (Long-Term Moving Average):</li>
</ol>
<p>Une moyenne mobile √† long terme est calcul√©e de mani√®re similaire, mais sur une p√©riode plus longue.
Cette moyenne mobile r√©agit plus lentement aux changements de prix.</p>
<br/>
<ol start="3">
<li>Signal d&rsquo;Achat - Golden Cross:</li>
</ol>
<p>Un signal d&rsquo;achat est g√©n√©r√© lorsque la moyenne mobile √† court terme (plus rapide) croise √† la hausse la moyenne mobile √† long terme (plus lente). Ce point de croisement est souvent appel√© un &ldquo;Golden Cross&rdquo; (croix dor√©e).
Le Golden Cross indique un potentiel changement dans la dynamique du march√©, sugg√©rant que la tendance pourrait passer d&rsquo;une tendance baissi√®re √† une tendance haussi√®re.</p>
<br/>
<ol start="4">
<li>Signal de Vente - Death Cross:</li>
</ol>
<p>√Ä l&rsquo;inverse, un signal de vente, souvent appel√© &ldquo;Death Cross&rdquo; (croix de la mort), se produit lorsque la moyenne mobile √† court terme croise √† la baisse la moyenne mobile √† long terme. Cela peut indiquer un potentiel changement de tendance √† la baisse.
La strat√©gie Golden Cross est souvent utilis√©e comme indicateur de confirmation de tendance. Cependant, il est important de noter que les signaux g√©n√©r√©s par cette strat√©gie peuvent parfois √™tre retard√©s, et il existe des p√©riodes o√π ils peuvent √™tre trompeurs, surtout dans des march√©s instables.</p>
<pre tabindex="0"><code>class GoldenCrossStrategy(bt.Strategy):
    params = ((&#39;sma_50&#39;, 50), (&#39;sma_200&#39;, 200), (&#39;order_percentage&#39;, 0.95))

    def __init__(self):
        # Create 50 SMA
        self.sma_moving_average_50 = bt.indicators.SMA(
            self.data.close, period=self.params.sma_50, plotname=&#39;50 day moving average&#39;
        )

        # Create 200 SMA
        self.sma_moving_average_200 = bt.indicators.SMA(
            self.data.close, period=self.params.sma_200, plotname=&#39;200 day moving average&#39;
        )

        # Create crossover using the SMA&#39;s
        self.crossover = bt.indicators.CrossOver(self.sma_moving_average_50, self.sma_moving_average_200)

    def next(self):

        # Open trade
        if self.position.size == 0:
            if self.crossover &gt; 0:
                amount_to_invest = (self.params.order_percentage * self.broker.cash)
                self.size = math.floor(amount_to_invest / self.data.close)

                print(&#34;Buy {} shares at {}&#34;.format(self.size, self.data.close[0]))
                self.buy(size=self.size)
        
        # Close trade
        if self.position.size &gt; 0:
            if self.crossover &lt; 0:      
                print(&#34;Sell {} shares at {}&#34;.format(self.size, self.data.close[0]))
                self.close()
</code></pre><p><img src="https://leandeep.com/images/backtrader5.png" alt="image"></p>
<br/>
<p><strong>EMA Strat√©gie:</strong></p>
<pre tabindex="0"><code>class EMAStrategy(bt.Strategy):
    params = (
        (&#34;short_period&#34;, 20),
        (&#34;long_period&#34;, 50),
    )

    def __init__(self):
        self.short_ema = bt.indicators.ExponentialMovingAverage(
            self.data.close, period=self.params.short_period
        )
        self.long_ema = bt.indicators.ExponentialMovingAverage(
            self.data.close, period=self.params.long_period
        )

    def next(self):
        if self.short_ema &gt; self.long_ema:
            # Condition d&#39;achat pour la strat√©gie EMA
            self.buy()

        elif self.short_ema &lt; self.long_ema:
            # Condition de vente pour la strat√©gie EMA
            self.sell()
</code></pre><p><img src="https://leandeep.com/images/backtrader6.png" alt="image"></p>
<br/>
<p><strong>SMA Strat√©gie:</strong></p>
<pre tabindex="0"><code>class SMAStrategy(bt.Strategy):

    def __init__(self):
        self.sma = bt.indicators.SMA()

    def next(self):
        if not self.position and self.data &gt; self.sma.lines.sma: 
           amount_to_invest = (0.95 * self.broker.cash)
           self.size = math.floor(amount_to_invest / self.data.close)

           print(&#34;Buy {} shares at {}&#34;.format(self.size, self.data.close[0]))
           self.buy(size=self.size)

        if self.position and self.data &lt; self.sma.lines.sma:
                print(&#34;Sell {} shares at {}&#34;.format(self.size, self.data.close[0]))
                self.close()
</code></pre><p><img src="https://leandeep.com/images/backtrader7.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie RMI:</strong></p>
<pre tabindex="0"><code>class RMI(bt.Strategy):
    
    params = ((&#39;upperband&#39;, 70.0), (&#39;lowerband&#39;, 30.0), (&#39;order_percentage&#39;, 0.95))

    def __init__(self):
        self.rmi = bt.indicators.RMI(self.data, period=20)

    def next(self):
        if not self.position and self.rmi &lt; self.params.lowerband: 
           amount_to_invest = (self.params.order_percentage * self.broker.cash)
           self.size = math.floor(amount_to_invest / self.data.close)

           print(&#34;Buy {} shares at {}&#34;.format(self.size, self.data.close[0]))
           self.buy(size=self.size)

        if self.position and self.rmi &gt; self.params.upperband:
                print(&#34;Sell {} shares at {}&#34;.format(self.size, self.data.close[0]))
                self.close()
</code></pre><p><img src="https://leandeep.com/images/backtrader8.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie RSI:</strong></p>
<pre tabindex="0"><code>class RSIStrategy(bt.Strategy):

    params = ((&#34;upperband&#34;, 85), (&#34;lowerband&#34;, 25), (&#34;order_percentage&#34;, 0.95))

    def __init__(self):
        self.rsi = bt.indicators.RSI(self.data, period=14)

    def next(self):
        if not self.position and self.rsi &lt; self.params.lowerband:
            amount_to_invest = self.params.order_percentage * self.broker.cash
            self.size = math.floor(amount_to_invest / self.data.close)

            print(&#34;Buy {} shares at {}&#34;.format(self.size, self.data.close[0]))
            self.buy(size=self.size)

        if self.position and self.rsi &gt; self.params.upperband:
            print(&#34;Sell {} shares at {}&#34;.format(self.size, self.data.close[0]))
            self.close()
</code></pre><p><img src="https://leandeep.com/images/backtrader9.png" alt="image"></p>
<br/>
<p><strong>Strat√©gie MACD:</strong></p>
<pre tabindex="0"><code>class MACDStrategy(bt.Strategy):

    params = ((&#39;ema_12&#39;, 12), (&#39;ema_26&#39;, 26), (&#39;order_percentage&#39;, 0.95))

    def __init__(self):     
        self.fast_ema_12 = bt.indicators.EMA(
            self.data.close, period = self.params.ema_12, plotname = &#39;12 day EMA&#39;
        )

        self.slow_ema_26 = bt.indicators.EMA(
            self.data.close, period = self.params.ema_26, plotname = &#39;26 day EMA&#39;
        )

        self.macd = bt.indicators.MACDHistogram(self.fast_ema_12, self.slow_ema_26)

    def next (self):
        if not self.position and self.macd &gt; 0:
            amount_to_invest = (self.params.order_percentage * self.broker.cash)
            self.size = math.floor(amount_to_invest / self.data.close)

            print(&#34;Buy {} shares at {}&#34;.format(self.size, self.data.close[0]))
            self.buy(size=self.size)

        if self.position and self.macd &lt; 0:
             print(&#34;Sell {} shares at {}&#34;.format(self.size, self.data.close[0]))
             self.close()
</code></pre><p><img src="https://leandeep.com/images/backtrader10.png" alt="image"></p>
<br/>
<p>Et voil√†, vous voyez √† quel point il est simple de coder des strat√©gies. Maintenant il ne vous reste plus qu&rsquo;√† √™tre inventif pour cr√©er une strat√©gie qui vous rapportera de l&rsquo;argent. Au moins vous avez un outil pour v√©rifier qu&rsquo;elle pourrait fonctionner (je dis bien pourrait car le pass√© ne pr√©sage pas le futur)&hellip; Je ne suis pas conseiller financier. Je ne recommande pas ces strat√©gies qui vous aurait fait perdre de l&rsquo;argent en 2022. Faites vos recherches.</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://leandeep.com/tags/python">Python</a></span><span class="tag"><a href="https://leandeep.com/tags/backtesting">Backtesting</a></span><span class="tag"><a href="https://leandeep.com/tags/backtrader">Backtrader</a></span><span class="tag"><a href="https://leandeep.com/tags/trading">Trading</a></span><span class="tag"><a href="https://leandeep.com/tags/algotrading">AlgoTrading</a></span>
                </p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>1614 Mots</p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>02 f√©vr.. 2024</p>
        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h"></span>
                    <hr />
                </div>

                <div class="pagination__buttons">
                    
                        <span class="button previous">
                            <a href="https://leandeep.com/install-tailscale-and-pi-hole-on-debian-11-bullseye/">
                                <span class="button__icon">‚Üê</span>
                                <span class="button__text">Install tailscale and Pi Hole on Debian 11 Bullseye</span>
                            </a>
                        </span>
                    

                    
                        <span class="button next">
                            <a href="https://leandeep.com/fixer-l%C3%A9cran-noir-de-kali-avec-utm/">
                                <span class="button__text">Fixer l&#39;√©cran noir de Kali avec UTM</span>
                                <span class="button__icon">‚Üí</span>
                            </a>
                        </span>
                    
                </div>
            </div>
        

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>Built by <a href="https://www.linkedin.com/in/oliviereeckhoutte/">Olivier Eeckhoutte</a>,
                Freelance @ LeanDeep <a href="https://leandeep.com/about/">(üçÉ company)</a></span>
            <span>Siret: 83825337500011</span>
            <span><a href="https://leandeep.com/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss">
                        <path d="M4 11a9 9 0 0 1 9 9"></path>
                        <path d="M4 4a16 16 0 0 1 16 16"></path>
                        <circle cx="5" cy="19" r="1"></circle>
                    </svg></a></span>
        </div>
    </div>
</footer>
            
        </div>

        




<script type="text/javascript" src="https://leandeep.com/bundle.min.c184f8481b5847ad1a7d8aa775944fa063f118cb4df68f4eaa3826a2a2e16b26a1ad798f5160210f265c6fbb9a5f19b953fed066ae1ed1092d1858bcff13ae92.js" integrity="sha512-wYT4SBtYR60afYqndZRPoGPxGMtN9o9OqjgmoqLhayahrXmPUWAhDyZcb7uaXxm5U/7QZq4e0QktGFi8/xOukg=="></script>







    </body>
</html>
