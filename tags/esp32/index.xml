<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ESP32 on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/esp32/</link>
    <description>Recent content in ESP32 on Lean Deep Tech blog</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 17 Apr 2025 22:49:00 +0200</lastBuildDate>
    <atom:link href="https://leandeep.com/tags/esp32/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Use an Oled display on ESP32 using Arduino</title>
      <link>https://leandeep.com/use-an-oled-display-on-esp32-using-arduino/</link>
      <pubDate>Thu, 17 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/use-an-oled-display-on-esp32-using-arduino/</guid>
      <description>&lt;p&gt;In this article we are going to see how to connect and display some content on an Oled display connected via I2C on an ESP-Wroom-32. The code is written in Arduino code.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;Install Arduino libraries:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Adafruit SSD1306&lt;/li&gt;&#xA;&lt;li&gt;Adafruit GFX Library&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;Connect the Oled display to the ESP32 board:&lt;/p&gt;&#xA;&lt;p&gt;Voici le branchement I2C entre ton ESP32 et l’écran :&lt;/p&gt;&#xA;&lt;p&gt;It is an OLED (NFP1315-61AY)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Connect VCC to 3.3V&lt;/li&gt;&#xA;&lt;li&gt;Of course connect GND to GND&lt;/li&gt;&#xA;&lt;li&gt;Connect SCL to GPIO22&lt;/li&gt;&#xA;&lt;li&gt;Connect SDA to GPIO21&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;Wire.h&amp;gt;&#xA;#include &amp;lt;Adafruit_GFX.h&amp;gt;&#xA;#include &amp;lt;Adafruit_SSD1306.h&amp;gt;&#xA;&#xA;#define SCREEN_WIDTH 128&#xA;#define SCREEN_HEIGHT 64&#xA;&#xA;// default I2C Adress is often 0x3C&#xA;#define OLED_ADDR 0x3C&#xA;&#xA;Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;amp;Wire, -1);&#xA;&#xA;void setup() {&#xA;  Wire.begin(21, 22); // SDA, SCL&#xA;  display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);&#xA;  display.clearDisplay();&#xA;&#xA;  display.setTextSize(1);&#xA;  display.setTextColor(SSD1306_WHITE);&#xA;  display.setCursor(0,0);&#xA;  display.println(&amp;#34;Hello Olivier!&amp;#34;);&#xA;  display.display();&#xA;}&#xA;&#xA;void loop() {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h2&gt;&#xA;&lt;p&gt;To find the Oled display address:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Use an Oled display on ESP32 using Rust</title>
      <link>https://leandeep.com/use-an-oled-display-on-esp32-using-rust/</link>
      <pubDate>Thu, 17 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/use-an-oled-display-on-esp32-using-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to connect and display some content on an Oled display connected via I2C on an ESP-Wroom-32. The code is written in Rust.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;Connect the Oled display to the ESP32 board:&lt;/p&gt;&#xA;&lt;p&gt;Voici le branchement I2C entre ton ESP32 et l’écran :&lt;/p&gt;&#xA;&lt;p&gt;It is an OLED (NFP1315-61AY)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Connect VCC to 3.3V&lt;/li&gt;&#xA;&lt;li&gt;Of course connect GND to GND&lt;/li&gt;&#xA;&lt;li&gt;Connect SCL to GPIO22&lt;/li&gt;&#xA;&lt;li&gt;Connect SDA to GPIO21&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;anyhow = &amp;#34;1.0&amp;#34;&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;&#xA;embedded-hal = &amp;#34;1.0.0&amp;#34;&#xA;embedded-graphics = &amp;#34;0.8.1&amp;#34;&#xA;ssd1306 = &amp;#34;0.10.0&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use anyhow::anyhow;&#xA;use esp_idf_hal::i2c::{I2cConfig, I2cDriver};&#xA;use esp_idf_hal::peripherals::Peripherals;&#xA;use esp_idf_hal::prelude::*;&#xA;use std::{thread, time::Duration}; // for .kHz()&#xA;&#xA;use embedded_graphics::{&#xA;    mono_font::{ascii::FONT_6X10, MonoTextStyle},&#xA;    pixelcolor::BinaryColor,&#xA;    prelude::*,&#xA;    text::Text,&#xA;};&#xA;&#xA;use ssd1306::{prelude::*, I2CDisplayInterface, Ssd1306};&#xA;&#xA;fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    let peripherals = Peripherals::take().unwrap();&#xA;    let i2c = peripherals.i2c0;&#xA;    let sda = peripherals.pins.gpio21;&#xA;    let scl = peripherals.pins.gpio22;&#xA;&#xA;    let config = I2cConfig::new().baudrate(400u32.kHz().into());&#xA;    let i2c_driver =&#xA;        I2cDriver::new(i2c, sda, scl, &amp;amp;config).map_err(|e| anyhow!(&amp;#34;I2C init error: {:?}&amp;#34;, e))?;&#xA;&#xA;    let interface = I2CDisplayInterface::new(i2c_driver);&#xA;    let mut display = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0)&#xA;        .into_buffered_graphics_mode();&#xA;&#xA;    display&#xA;        .init()&#xA;        .map_err(|e| anyhow!(&amp;#34;Display init error: {:?}&amp;#34;, e))?;&#xA;    display&#xA;        .flush()&#xA;        .map_err(|e| anyhow!(&amp;#34;Flush error: {:?}&amp;#34;, e))?;&#xA;&#xA;    let style = MonoTextStyle::new(&amp;amp;FONT_6X10, BinaryColor::On);&#xA;    Text::new(&amp;#34;Hello Olivier !!!&amp;#34;, Point::new(10, 32), style)&#xA;        .draw(&amp;amp;mut display)&#xA;        .map_err(|e| anyhow!(&amp;#34;Draw error: {:?}&amp;#34;, e))?;&#xA;&#xA;    display&#xA;        .flush()&#xA;        .map_err(|e| anyhow!(&amp;#34;Final flush error: {:?}&amp;#34;, e))?;&#xA;&#xA;    loop {&#xA;        thread::sleep(Duration::from_millis(1000));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;build&#34;&gt;Build&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# cargo generate --git https://github.com/esp-rs/esp-idf-template cargo&#xA;source ~/export-esp.sh&#xA;cargo build&#xA;espflash flash target/xtensa-esp32-espidf/debug/oled --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Read and write file in sdcard from ESP32 and Rust</title>
      <link>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</link>
      <pubDate>Sun, 13 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to read a file from a SD Card in Rust using the SPI port of the ESP32.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cargo install esp-generate@0.3.1&#xA;esp-generate --chip esp32 sd&#xA;source ~/export-esp.sh&#xA;cargo build&#xA;# espflash flash target/xtensa-esp32-none-elf/debug/sd --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;critical-section = &amp;#34;1.2.0&amp;#34;&#xA;embassy-executor = { version = &amp;#34;0.7.0&amp;#34;, features = [&amp;#34;task-arena-size-20480&amp;#34;] }&#xA;embassy-time     = { version = &amp;#34;0.4.0&amp;#34;, features = [&amp;#34;generic-queue-8&amp;#34;] }&#xA;esp-hal          = { version = &amp;#34;1.0.0-beta.0&amp;#34;, features = [&amp;#34;esp32&amp;#34;, &amp;#34;unstable&amp;#34;] }&#xA;esp-hal-embassy  = { version = &amp;#34;0.7.0&amp;#34;, features = [&amp;#34;esp32&amp;#34;] }&#xA;static_cell      = { version = &amp;#34;2.1.0&amp;#34;, features = [&amp;#34;nightly&amp;#34;] }&#xA;# sd card driver&#xA;embedded-sdmmc = &amp;#34;0.8.1&amp;#34;&#xA;# To convert Spi bus to SpiDevice&#xA;embedded-hal-bus = &amp;#34;0.3.0&amp;#34;&#xA;## For time parsing&#xA;chrono = { version = &amp;#34;0.4.40&amp;#34;, default-features = false }&#xA;esp-println = { version = &amp;#34;0.12.0&amp;#34;, features = [&amp;#34;esp32&amp;#34;, &amp;#34;log&amp;#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//cargo install esp-generate@0.3.1&#xA;//esp-generate --chip esp32 sd&#xA;//source ~/export-esp.sh&#xA;//cargo build&#xA;//espflash flash target/xtensa-esp32-none-elf/debug/sd --monitor&#xA;&#xA;#![no_std]&#xA;#![no_main]&#xA;&#xA;use embassy_executor::Spawner;&#xA;use embassy_time::{Delay, Duration, Timer};&#xA;use embedded_hal_bus::spi::ExclusiveDevice;&#xA;use embedded_sdmmc::{SdCard, TimeSource, Timestamp, VolumeIdx, VolumeManager};&#xA;use esp_hal::clock::CpuClock;&#xA;use esp_hal::gpio::{Level, Output, OutputConfig};&#xA;use esp_hal::spi;&#xA;use esp_hal::spi::master::Spi;&#xA;use esp_hal::time::Rate;&#xA;use esp_hal::timer::timg::TimerGroup;&#xA;use esp_println::{self as _, print, println};&#xA;&#xA;#[panic_handler]&#xA;fn panic(_: &amp;amp;core::panic::PanicInfo) -&amp;gt; ! {&#xA;    loop {}&#xA;}&#xA;&#xA;/// Code from https://github.com/rp-rs/rp-hal-boards/blob/main/boards/rp-pico/examples/pico_spi_sd_card.rs&#xA;/// A dummy timesource, which is mostly important for creating files.&#xA;#[derive(Default)]&#xA;pub struct DummyTimesource();&#xA;&#xA;impl TimeSource for DummyTimesource {&#xA;    // In theory you could use the RTC of the rp2040 here, if you had&#xA;    // any external time synchronizing device.&#xA;    fn get_timestamp(&amp;amp;self) -&amp;gt; Timestamp {&#xA;        Timestamp {&#xA;            year_since_1970: 0,&#xA;            zero_indexed_month: 0,&#xA;            zero_indexed_day: 0,&#xA;            hours: 0,&#xA;            minutes: 0,&#xA;            seconds: 0,&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;#[esp_hal_embassy::main]&#xA;async fn main(_spawner: Spawner) {&#xA;    let config = esp_hal::Config::default().with_cpu_clock(CpuClock::max());&#xA;    let peripherals = esp_hal::init(config);&#xA;&#xA;    let timer0 = TimerGroup::new(peripherals.TIMG1);&#xA;    esp_hal_embassy::init(timer0.timer0);&#xA;&#xA;    println!(&amp;#34;Embassy initialized!&amp;#34;);&#xA;&#xA;    let spi_bus = Spi::new(&#xA;        peripherals.SPI2,&#xA;        spi::master::Config::default()&#xA;            .with_frequency(Rate::from_khz(400))&#xA;            .with_mode(spi::Mode::_0),&#xA;    )&#xA;    .unwrap()&#xA;    .with_sck(peripherals.GPIO18)&#xA;    .with_mosi(peripherals.GPIO23)&#xA;    .with_miso(peripherals.GPIO19)&#xA;    .into_async();&#xA;    let sd_cs = Output::new(peripherals.GPIO5, Level::High, OutputConfig::default());&#xA;    let spi_dev = ExclusiveDevice::new(spi_bus, sd_cs, Delay).unwrap();&#xA;&#xA;    let sdcard = SdCard::new(spi_dev, Delay);&#xA;    let mut volume_mgr = VolumeManager::new(sdcard, DummyTimesource::default());&#xA;&#xA;    println!(&amp;#34;Init SD card controller and retrieve card size...&amp;#34;);&#xA;    let sd_size = volume_mgr.device().num_bytes().unwrap();&#xA;    println!(&amp;#34;SD card size is {} bytes\r\n&amp;#34;, sd_size);&#xA;&#xA;    let mut volume0 = volume_mgr.open_volume(VolumeIdx(0)).unwrap();&#xA;    let mut root_dir = volume0.open_root_dir().unwrap();&#xA;    {&#xA;        let mut my_file = root_dir&#xA;            .open_file_in_dir(&#xA;                &amp;#34;example.txt&amp;#34;,&#xA;                embedded_sdmmc::Mode::ReadWriteCreateOrTruncate,&#xA;            )&#xA;            .unwrap();&#xA;&#xA;        let line = &amp;#34;Hello Rust!&amp;#34;;&#xA;        if let Ok(()) = my_file.write(line.as_bytes()) {&#xA;            my_file.flush().unwrap();&#xA;            println!(&amp;#34;Written Data&amp;#34;);&#xA;        } else {&#xA;            println!(&amp;#34;Not written&amp;#34;);&#xA;        }&#xA;    }&#xA;    {&#xA;        let mut my_file = root_dir&#xA;            .open_file_in_dir(&amp;#34;example.txt&amp;#34;, embedded_sdmmc::Mode::ReadOnly)&#xA;            .unwrap();&#xA;&#xA;        while !my_file.is_eof() {&#xA;            let mut buffer = [0u8; 32];&#xA;&#xA;            if let Ok(n) = my_file.read(&amp;amp;mut buffer) {&#xA;                for b in &amp;amp;buffer[..n] {&#xA;                    print!(&amp;#34;{}&amp;#34;, *b as char);&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    loop {&#xA;        Timer::after(Duration::from_secs(30)).await;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Add a MicroSD card adapter on a ESP32 (Arduino code and OSX)</title>
      <link>https://leandeep.com/add-a-microsd-card-adapter-on-a-esp32-arduino-code-and-osx/</link>
      <pubDate>Fri, 11 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/add-a-microsd-card-adapter-on-a-esp32-arduino-code-and-osx/</guid>
      <description>&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Arduino IDE installed&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;arduino-cli&lt;/code&gt; installed on OSX (using &lt;code&gt;brew install arduino-cli&lt;/code&gt;) to ease monitoring via the command &lt;code&gt;arduino-cli monitor -p /dev/ttyUSB0 -c baudrate=115200&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Determine ESP32 SPI GPIO Pins. To do that you can the following code:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void setup() {&#xA;  Serial.begin(115200);&#xA;&#xA;  Serial.print(&amp;#34;MOSI: &amp;#34;);&#xA;  Serial.println(MOSI); // MOSI Pin by default&#xA;  Serial.print(&amp;#34;MISO: &amp;#34;);&#xA;  Serial.println(MISO); // MISO Pin by default&#xA;  Serial.print(&amp;#34;SCK: &amp;#34;);&#xA;  Serial.println(SCK); // SCK Pin by default&#xA;  Serial.print(&amp;#34;CS: &amp;#34;);&#xA;  Serial.println(SS); // CS Pin by default&#xA;}&#xA;&#xA;void loop() {&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;Install &lt;code&gt;SD&lt;/code&gt; library from Arduino IDE&lt;/li&gt;&#xA;&lt;li&gt;I connected VCC to 5V, GND to GND, MISO to pin 19, MOSI to pin 23, SCK to pin 18 and CS to pin 5.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;arduino-code&#34;&gt;Arduino Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;FS.h&amp;gt;&#xA;#include &amp;lt;SD.h&amp;gt;&#xA;#include &amp;lt;SPI.h&amp;gt;&#xA;&#xA;void setup() {&#xA;  Serial.begin(115200);&#xA;&#xA;  // Init SD card&#xA;  if (!SD.begin(5)) { // GPIO 5 is used for CS&#xA;    Serial.println(&amp;#34;Could not mount SD card&amp;#34;);&#xA;    return;&#xA;  }&#xA;&#xA;  Serial.println(&amp;#34;SD card successfully mounted&amp;#34;);&#xA;&#xA;  // Display SD card informations&#xA;  uint64_t cardSize = SD.cardSize() / (1024 * 1024);&#xA;  Serial.printf(&amp;#34;SD card size: %llu MB\n&amp;#34;, cardSize);&#xA;&#xA;  // Create example file&#xA;  writeFile(SD, &amp;#34;/example.txt&amp;#34;, &amp;#34;This is an example file.&amp;#34;);&#xA;  &#xA;  // Read and display the files in the root dir&#xA;  listDir(SD, &amp;#34;/&amp;#34;, 0);&#xA;}&#xA;&#xA;void loop() {&#xA;  // Nothing to do&#xA;}&#xA;&#xA;// Function to list files in a directory&#xA;void listDir(fs::FS &amp;amp;fs, const char * dirname, uint8_t levels) {&#xA;  Serial.printf(&amp;#34;Directory listing: %s\n&amp;#34;, dirname);&#xA;&#xA;  File root = fs.open(dirname);&#xA;  if (!root || !root.isDirectory()) {&#xA;    Serial.println(&amp;#34;Could not open directory Or it is not a directory&amp;#34;);&#xA;    return;&#xA;  }&#xA;&#xA;  File file = root.openNextFile();&#xA;  while (file) {&#xA;    if (file.isDirectory()) {&#xA;      Serial.print(&amp;#34;DIR : &amp;#34;);&#xA;      Serial.println(file.name());&#xA;      if (levels) {&#xA;        listDir(fs, file.name(), levels - 1);&#xA;      }&#xA;    } else {&#xA;      Serial.print(&amp;#34;FICHIER : &amp;#34;);&#xA;      Serial.print(file.name());&#xA;      Serial.print(&amp;#34; TAILLE : &amp;#34;);&#xA;      Serial.println(file.size());&#xA;    }&#xA;    file = root.openNextFile();&#xA;  }&#xA;}&#xA;&#xA;// Function to write a file&#xA;void writeFile(fs::FS &amp;amp;fs, const char * path, const char * message) {&#xA;  Serial.printf(&amp;#34;Writing in file: %s\n&amp;#34;, path);&#xA;&#xA;  File file = fs.open(path, FILE_WRITE);&#xA;  if (!file) {&#xA;    Serial.println(&amp;#34;Could not open file to write into it&amp;#34;);&#xA;    return;&#xA;  }&#xA;&#xA;  if (file.print(message)) {&#xA;    Serial.println(&amp;#34;File successfully written&amp;#34;);&#xA;  } else {&#xA;    Serial.println(&amp;#34;Impossible to write file&amp;#34;);&#xA;  }&#xA;&#xA;  file.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;In a next article we will see how to do the same thing with Rust.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Get ESP32 cores count and use multithreading in Rust</title>
      <link>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</link>
      <pubDate>Tue, 08 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</guid>
      <description>&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;anyhow = &amp;#34;1.0&amp;#34;&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;count-cores-code&#34;&gt;Count cores code&lt;/h2&gt;&#xA;&lt;p&gt;Now update &lt;code&gt;main.rs&lt;/code&gt; and add this code:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use esp_idf_hal::cpu;&#xA;use esp_idf_svc::log::EspLogger;&#xA;&#xA;fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Starting program...&amp;#34;);&#xA;&#xA;    let cpu_cores = cpu::CORES;&#xA;    log::info!(&amp;#34;Cores count : {}&amp;#34;, cpu_cores);&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;build-and-run&#34;&gt;Build and Run&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cargo generate --git https://github.com/esp-rs/esp-idf-template cargo&#xA;cd core&#xA;source ~/export-esp.sh&#xA;cargo build&#xA;espflash flash target/xtensa-esp32-espidf/debug/core --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;execute-code-in-different-threads-code&#34;&gt;Execute code in different threads code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use core::time::Duration;&#xA;use std::thread;&#xA;fn main() {&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Starting multi-threaded example on ESP32&amp;#34;);&#xA;&#xA;    // Spawn thread 1 on Core 0&#xA;    thread::spawn(|| {&#xA;        loop {&#xA;            log::info!(&amp;#34;Task running on Core 0&amp;#34;);&#xA;            thread::sleep(Duration::from_secs(2)); // Simulate work&#xA;        }&#xA;    });&#xA;&#xA;    // Spawn thread 2 on Core 1&#xA;    thread::spawn(|| {&#xA;        loop {&#xA;            log::info!(&amp;#34;Task running on Core 1&amp;#34;);&#xA;            thread::sleep(Duration::from_secs(4)); // Simulate work&#xA;        }&#xA;    });&#xA;&#xA;    // Keep the main thread alive&#xA;    loop {&#xA;        thread::sleep(Duration::from_secs(10));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;execute-code-in-different-threads-and-share-variable&#34;&gt;Execute code in different threads and share variable&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use core::time::Duration;&#xA;use std::sync::{Arc, Mutex};&#xA;use std::thread;&#xA;&#xA;fn main() {&#xA;    // Initialisation du logger&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Starting program&amp;#34;);&#xA;&#xA;    // Shared variable between threads&#xA;    let shared_counter = Arc::new(Mutex::new(0));&#xA;&#xA;    // Spawn thread 1 on Core 0&#xA;    let counter_thread_1 = Arc::clone(&amp;amp;shared_counter);&#xA;    thread::spawn(move || {&#xA;        loop {&#xA;            {&#xA;                let mut counter = counter_thread_1.lock().unwrap();&#xA;                *counter += 1;&#xA;                log::info!(&amp;#34;Core 0 incremented counter to {}&amp;#34;, *counter);&#xA;            }&#xA;            thread::sleep(Duration::from_secs(2)); // Simule du travail&#xA;        }&#xA;    });&#xA;&#xA;    // Spawn thread 2 on Core 1&#xA;    let counter_thread_2 = Arc::clone(&amp;amp;shared_counter);&#xA;    thread::spawn(move || {&#xA;        loop {&#xA;            {&#xA;                let mut counter = counter_thread_2.lock().unwrap();&#xA;                *counter += 2;&#xA;                log::info!(&amp;#34;Core 1 incremented counter to {}&amp;#34;, *counter);&#xA;            }&#xA;            thread::sleep(Duration::from_secs(4)); // Simule du travail&#xA;        }&#xA;    });&#xA;&#xA;    // Main Thread: read shared variable value&#xA;    loop {&#xA;        {&#xA;            let counter = shared_counter.lock().unwrap();&#xA;            log::info!(&amp;#34;Main thread reads counter: {}&amp;#34;, *counter);&#xA;        }&#xA;        thread::sleep(Duration::from_secs(5));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Scan Wifi networks on ESP32 using Rust</title>
      <link>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</link>
      <pubDate>Tue, 08 Apr 2025 20:49:00 +0200</pubDate>
      <guid>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to scan Wifi networks around you.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;The crates used are the following ones:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use esp_idf_hal::prelude::*;&#xA;use esp_idf_svc::eventloop::EspSystemEventLoop;&#xA;use esp_idf_svc::nvs::EspDefaultNvsPartition;&#xA;use esp_idf_svc::sys::EspError;&#xA;use esp_idf_svc::wifi::{AuthMethod, BlockingWifi, ClientConfiguration, Configuration, EspWifi};&#xA;use std::thread;&#xA;use std::time::Duration;&#xA;&#xA;fn main() -&amp;gt; Result&amp;lt;(), EspError&amp;gt; {&#xA;    esp_idf_svc::sys::link_patches();&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::set_max_level(log::LevelFilter::Info);&#xA;    log::info!(&amp;#34;Program started!&amp;#34;);&#xA;&#xA;    // Init needed components&#xA;    let peripherals = Peripherals::take().unwrap();&#xA;    let nvs = EspDefaultNvsPartition::take()?;&#xA;    let sys_loop = EspSystemEventLoop::take()?;&#xA;&#xA;    // Init WiFi&#xA;    let esp_wifi = EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?;&#xA;    let mut wifi = BlockingWifi::wrap(esp_wifi, sys_loop)?;&#xA;&#xA;    let wifi_config = Configuration::Client(ClientConfiguration::default());&#xA;    wifi.set_configuration(&amp;amp;wifi_config)?;&#xA;&#xA;    wifi.start()?;&#xA;    println!(&amp;#34;WiFi started in station mode&amp;#34;);&#xA;    thread::sleep(Duration::from_secs(2));&#xA;&#xA;    // Boucle infinie pour scanner les réseaux&#xA;    loop {&#xA;        println!(&amp;#34;\n=== Scanning WiFi networks... ===&amp;#34;);&#xA;&#xA;        match wifi.scan() {&#xA;            Ok(scan_result) =&amp;gt; {&#xA;                println!(&amp;#34;{} WiFi networks detected:&amp;#34;, scan_result.len());&#xA;&#xA;                // Sort networks per signal power (stronger first)&#xA;                let mut networks = scan_result;&#xA;                networks.sort_by(|a, b| b.signal_strength.cmp(&amp;amp;a.signal_strength));&#xA;&#xA;                for (i, ap) in networks.iter().enumerate() {&#xA;                    // Convert SSID to String&#xA;                    let ssid = if ap.ssid.is_empty() {&#xA;                        &amp;#34;&amp;lt;Hidden network&amp;gt;&amp;#34;.to_string()&#xA;                    } else {&#xA;                        ap.ssid.to_string()&#xA;                    };&#xA;&#xA;                    // Format BSSID to MAC address&#xA;                    let mac = format!(&#xA;                        &amp;#34;{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}&amp;#34;,&#xA;                        ap.bssid[0],&#xA;                        ap.bssid[1],&#xA;                        ap.bssid[2],&#xA;                        ap.bssid[3],&#xA;                        ap.bssid[4],&#xA;                        ap.bssid[5]&#xA;                    );&#xA;&#xA;                    println!(&#xA;                        &amp;#34;{:2}. SSID: {:32} | Signal: {:4} dBm | Channel: {:2} | MAC: {:17} | Security: {:?}&amp;#34;,&#xA;                        i + 1,&#xA;                        ssid,&#xA;                        ap.signal_strength,&#xA;                        ap.channel,&#xA;                        mac,&#xA;                        auth_method_to_string(ap.auth_method)&#xA;                    );&#xA;                }&#xA;            }&#xA;            Err(e) =&amp;gt; {&#xA;                println!(&amp;#34;Error while scanning: {:?}&amp;#34;, e);&#xA;            }&#xA;        }&#xA;&#xA;        println!(&amp;#34;Wait 5 seconds before next scan...&amp;#34;);&#xA;        thread::sleep(Duration::from_secs(5));&#xA;    }&#xA;}&#xA;&#xA;fn auth_method_to_string(auth: Option&amp;lt;AuthMethod&amp;gt;) -&amp;gt; &amp;amp;&amp;#39;static str {&#xA;    match auth {&#xA;        Some(AuthMethod::None) =&amp;gt; &amp;#34;Open&amp;#34;,&#xA;        Some(AuthMethod::WEP) =&amp;gt; &amp;#34;WEP&amp;#34;,&#xA;        Some(AuthMethod::WPA) =&amp;gt; &amp;#34;WPA&amp;#34;,&#xA;        Some(AuthMethod::WPA2Personal) =&amp;gt; &amp;#34;WPA2-Personal&amp;#34;,&#xA;        Some(AuthMethod::WPA3Personal) =&amp;gt; &amp;#34;WPA3-Personal&amp;#34;,&#xA;        Some(AuthMethod::WPA2Enterprise) =&amp;gt; &amp;#34;WPA2-Enterprise&amp;#34;,&#xA;        Some(AuthMethod::WPA2WPA3Personal) =&amp;gt; &amp;#34;WPA2/WPA3&amp;#34;,&#xA;        None =&amp;gt; &amp;#34;Unknown&amp;#34;,&#xA;        _ =&amp;gt; &amp;#34;Unknown&amp;#34;,&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Get GPS coordinates on ESP32 using basic Arduino code</title>
      <link>https://leandeep.com/get-gps-coordinates-on-esp32-using-basic-arduino-code/</link>
      <pubDate>Wed, 02 Apr 2025 20:49:00 +0200</pubDate>
      <guid>https://leandeep.com/get-gps-coordinates-on-esp32-using-basic-arduino-code/</guid>
      <description>&lt;p&gt;In this article we are going to see how to retrieve NMEA sentences from a GPS module NEO-6M connected to an ESP32.&lt;/p&gt;&#xA;&lt;p&gt;&lt;br/&gt;&#xA;Connect the NEO-6M GPS module to the ESP32&#xA;&lt;br/&gt;&#xA;Then create an Arduino program and deploy it to the ESP-wroom-32.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arduino-cli sketch new arduino-gps&#xA;cd arduino-gps/&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&#xA;Edit the arduino-gps.ino file and add the following content:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define RXD2 16&#xA;#define TXD2 17&#xA;&#xA;#define GPS_BAUD 9600&#xA;&#xA;// Create an instance of the HardwareSerial class for Serial 2&#xA;HardwareSerial gpsSerial(2);&#xA;&#xA;void setup(){&#xA;  // Serial Monitor&#xA;  Serial.begin(115200);&#xA;&#xA;  // Start Serial 2 with the defined RX and TX pins and a baud rate of 9600&#xA;  gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2);&#xA;  Serial.println(&amp;#34;Serial 2 started at 9600 baud rate&amp;#34;);&#xA;}&#xA;&#xA;void loop(){&#xA;  while (gpsSerial.available() &amp;gt; 0){&#xA;    // get the byte data from the GPS&#xA;    char gpsData = gpsSerial.read();&#xA;    Serial.print(gpsData);&#xA;  }&#xA;  delay(1000);&#xA;  Serial.println(&amp;#34;-------------------------------&amp;#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&#xA;Compile and deploy:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Get GPS coordinates on ESP32 using Rust</title>
      <link>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</link>
      <pubDate>Wed, 02 Apr 2025 20:49:00 +0200</pubDate>
      <guid>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to retrieve NMEA sentences from a GPS module NEO-6M connected to an ESP32.&lt;/p&gt;&#xA;&lt;p&gt;&lt;br/&gt;&#xA;Connect the NEO-6M GPS module to the ESP32&#xA;&lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/esp-gps.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Dependencies:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&#xA;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use esp_idf_hal::peripherals::Peripherals;&#xA;use esp_idf_hal::prelude::*;&#xA;use esp_idf_hal::uart::*;&#xA;use esp_idf_svc::hal::uart::config::DataBits;&#xA;use esp_idf_svc::hal::uart::config::StopBits;&#xA;&#xA;fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {&#xA;    // Lien des patches ESP-IDF&#xA;    esp_idf_svc::sys::link_patches();&#xA;    &#xA;    // Configuration du logger&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Démarrage de l&amp;#39;application GPS&amp;#34;);&#xA;&#xA;    // Initialisation des périphériques&#xA;    let peripherals = Peripherals::take().unwrap();&#xA;    &#xA;    // Configuration de l&amp;#39;UART&#xA;    let config = config::Config::default()&#xA;        .baudrate(Hertz(9600))&#xA;        .data_bits(DataBits::DataBits8)&#xA;        .parity_none()&#xA;        .stop_bits(StopBits::STOP1);&#xA;&#xA;    // Création du driver UART avec typage explicite&#xA;    let mut uart_driver = UartDriver::new(&#xA;        peripherals.uart2,&#xA;        peripherals.pins.gpio17, // TX&#xA;        peripherals.pins.gpio16, // RX&#xA;        Option::&amp;lt;esp_idf_hal::gpio::Gpio0&amp;gt;::None, // RTS (pas utilisé)&#xA;        Option::&amp;lt;esp_idf_hal::gpio::Gpio0&amp;gt;::None, // CTS (pas utilisé)&#xA;        &amp;amp;config,&#xA;    )?;&#xA;&#xA;    println!(&amp;#34;UART initialisé avec un débit de 9600 bauds&amp;#34;);&#xA;&#xA;    // Buffer pour stocker les données GPS&#xA;    let mut buffer = [0u8; 128];&#xA;    &#xA;    loop {&#xA;        // Lecture des données disponibles sur l&amp;#39;UART avec timeout&#xA;        match uart_driver.read(&amp;amp;mut buffer, 1000) {&#xA;            Ok(bytes_read) if bytes_read &amp;gt; 0 =&amp;gt; {&#xA;                let gps_data = &amp;amp;buffer[..bytes_read];&#xA;                println!(&#xA;                    &amp;#34;Données GPS reçues : {}&amp;#34;,&#xA;                    String::from_utf8_lossy(gps_data)&#xA;                );&#xA;            },&#xA;            Ok(_) =&amp;gt; {&#xA;                println!(&amp;#34;Aucune donnée GPS reçue (timeout)&amp;#34;);&#xA;            },&#xA;            Err(e) =&amp;gt; {&#xA;                println!(&amp;#34;Erreur de lecture UART: {:?}&amp;#34;, e);&#xA;            }&#xA;        }&#xA;&#xA;        println!(&amp;#34;-------------------------------&amp;#34;);&#xA;        std::thread::sleep(std::time::Duration::from_secs(1));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Connect ESP32 to wifi network using Rust</title>
      <link>https://leandeep.com/connect-esp32-to-wifi-network-using-rust/</link>
      <pubDate>Fri, 28 Mar 2025 15:49:00 +0200</pubDate>
      <guid>https://leandeep.com/connect-esp32-to-wifi-network-using-rust/</guid>
      <description>&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;anyhow = &amp;#34;1&amp;#34;&#xA;embedded-svc = { version = &amp;#34;0.28&amp;#34;, default-features = false }&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;p&gt;Now update &lt;code&gt;main.rs&lt;/code&gt; and add this code:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use core::convert::TryInto;&#xA;use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};&#xA;&#xA;use esp_idf_svc::hal::prelude::Peripherals;&#xA;use esp_idf_svc::log::EspLogger;&#xA;use esp_idf_svc::wifi::{BlockingWifi, EspWifi};&#xA;use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition};&#xA;&#xA;use log::info;&#xA;&#xA;const SSID: &amp;amp;str = &amp;#34;SSID&amp;#34;;&#xA;const PASSWORD: &amp;amp;str = &amp;#34;password&amp;#34;;&#xA;&#xA;fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    esp_idf_svc::sys::link_patches();&#xA;    EspLogger::initialize_default();&#xA;&#xA;    let peripherals = Peripherals::take()?;&#xA;    let sys_loop = EspSystemEventLoop::take()?;&#xA;    let nvs = EspDefaultNvsPartition::take()?;&#xA;&#xA;    let mut wifi = BlockingWifi::wrap(&#xA;        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?,&#xA;        sys_loop,&#xA;    )?;&#xA;&#xA;    connect_wifi(&amp;amp;mut wifi)?;&#xA;&#xA;    let ip_info = wifi.wifi().sta_netif().get_ip_info()?;&#xA;&#xA;    info!(&amp;#34;Wifi DHCP info: {:?}&amp;#34;, ip_info);&#xA;&#xA;    info!(&amp;#34;Shutting down in 5s...&amp;#34;);&#xA;&#xA;    std::thread::sleep(core::time::Duration::from_secs(5));&#xA;&#xA;    Ok(())&#xA;}&#xA;&#xA;fn connect_wifi(wifi: &amp;amp;mut BlockingWifi&amp;lt;EspWifi&amp;lt;&amp;#39;static&amp;gt;&amp;gt;) -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {&#xA;        ssid: SSID.try_into().unwrap(),&#xA;        bssid: None,&#xA;        auth_method: AuthMethod::WPA2Personal,&#xA;        password: PASSWORD.try_into().unwrap(),&#xA;        channel: None,&#xA;        ..Default::default()&#xA;    });&#xA;&#xA;    wifi.set_configuration(&amp;amp;wifi_configuration)?;&#xA;&#xA;    wifi.start()?;&#xA;    info!(&amp;#34;Wifi started&amp;#34;);&#xA;&#xA;    wifi.connect()?;&#xA;    info!(&amp;#34;Wifi connected&amp;#34;);&#xA;&#xA;    wifi.wait_netif_up()?;&#xA;    info!(&amp;#34;Wifi netif up&amp;#34;);&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;build-and-run&#34;&gt;Build and Run&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cargo build&#xA;espflash flash target/xtensa-esp32-espidf/debug/blink --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Power on a PC when a button is pushed on an ESP32 using Rust</title>
      <link>https://leandeep.com/power-on-a-pc-when-a-button-is-pushed-on-an-esp32-using-rust/</link>
      <pubDate>Fri, 28 Mar 2025 15:49:00 +0200</pubDate>
      <guid>https://leandeep.com/power-on-a-pc-when-a-button-is-pushed-on-an-esp32-using-rust/</guid>
      <description>&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;anyhow = &amp;#34;1&amp;#34;&#xA;embedded-svc = { version = &amp;#34;0.28&amp;#34;, default-features = false }&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;p&gt;Now update &lt;code&gt;main.rs&lt;/code&gt; and add this code:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xA;use core::convert::TryInto;&#xA;use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};&#xA;&#xA;//use esp_idf_svc::hal::prelude::Peripherals;&#xA;use esp_idf_svc::log::EspLogger;&#xA;use esp_idf_svc::wifi::{BlockingWifi, EspWifi};&#xA;use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition};&#xA;&#xA;use log::info;&#xA;use std::net::{UdpSocket, Ipv4Addr, SocketAddrV4};&#xA;use std::time::Duration;&#xA;use esp_idf_hal::delay::FreeRtos;&#xA;use esp_idf_hal::gpio::PinDriver;&#xA;use esp_idf_hal::peripherals::Peripherals;&#xA;&#xA;const SSID: &amp;amp;str = &amp;#34;...&amp;#34;;&#xA;const PASSWORD: &amp;amp;str = &amp;#34;...&amp;#34;;&#xA;&#xA;fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    esp_idf_svc::sys::link_patches();&#xA;    EspLogger::initialize_default();&#xA;&#xA;    let peripherals = Peripherals::take()?;&#xA;    let sys_loop = EspSystemEventLoop::take()?;&#xA;    let nvs = EspDefaultNvsPartition::take()?;&#xA;&#xA;    let mut wifi = BlockingWifi::wrap(&#xA;        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?,&#xA;        sys_loop,&#xA;    )?;&#xA;&#xA;    connect_wifi(&amp;amp;mut wifi)?;&#xA;&#xA;    let ip_info = wifi.wifi().sta_netif().get_ip_info()?;&#xA;&#xA;    info!(&amp;#34;Wifi DHCP info: {:?}&amp;#34;, ip_info);&#xA;    &#xA;    //let peripherals = Peripherals::take().unwrap();&#xA;    let pins = peripherals.pins;&#xA;&#xA;    let mut led = PinDriver::output(pins.gpio2).unwrap();&#xA;    let button = PinDriver::input(pins.gpio35).unwrap();&#xA;    let mac: [u8; 6] = [0x94, 0xC6, 0x91, 0xAD, 0x1D, 0x49];&#xA;    loop {&#xA;        if button.is_high() {&#xA;            log::info!(&amp;#34;Switch ON&amp;#34;);&#xA;            led.set_high().unwrap(); // Switch ON LED&#xA;            send_wol(&amp;amp;mac);&#xA;            &#xA;        } else {&#xA;            log::info!(&amp;#34;Switch OFF&amp;#34;);&#xA;            led.set_low().unwrap();  // Switch OFF LED&#xA;        }&#xA;        FreeRtos::delay_ms(1000u32);&#xA;    }&#xA;    &#xA;}&#xA;&#xA;fn connect_wifi(wifi: &amp;amp;mut BlockingWifi&amp;lt;EspWifi&amp;lt;&amp;#39;static&amp;gt;&amp;gt;) -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {&#xA;        ssid: SSID.try_into().unwrap(),&#xA;        bssid: None,&#xA;        auth_method: AuthMethod::WPA2Personal,&#xA;        password: PASSWORD.try_into().unwrap(),&#xA;        channel: None,&#xA;        ..Default::default()&#xA;    });&#xA;&#xA;    wifi.set_configuration(&amp;amp;wifi_configuration)?;&#xA;&#xA;    wifi.start()?;&#xA;    info!(&amp;#34;Wifi started&amp;#34;);&#xA;&#xA;    wifi.connect()?;&#xA;    info!(&amp;#34;Wifi connected&amp;#34;);&#xA;&#xA;    wifi.wait_netif_up()?;&#xA;    info!(&amp;#34;Wifi netif up&amp;#34;);&#xA;    send_wol(&amp;amp;mac);&#xA;    &#xA;    Ok(())&#xA;}&#xA;&#xA;fn send_wol(mac: &amp;amp;[u8; 6]) {&#xA;    info!(&amp;#34;Sending WOL request on the LAN&amp;#34;);&#xA;    let mut packet: Vec&amp;lt;u8&amp;gt; = vec![0xFF; 6]; // 6 octets at 0xFF&#xA;    packet.extend_from_slice(&amp;amp;mac.repeat(16)); // repeat the MAC address 16 times&#xA;    let socket = UdpSocket::bind(&amp;#34;0.0.0.0:0&amp;#34;).expect(&amp;#34;Impossible to bind socket&amp;#34;);&#xA;    socket.set_read_timeout(Some(Duration::from_secs(2))).unwrap();&#xA;    let addr = SocketAddrV4::new(Ipv4Addr::new(255, 255, 255, 255), 9);&#xA;    socket&#xA;        .send_to(&amp;amp;packet, addr)&#xA;        .expect(&amp;#34;Failed sending WOL packet&amp;#34;);&#xA;&#xA;    info!(&amp;#34;Wake-on-LAN sent to MAC: {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}&amp;#34;, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;build-and-run&#34;&gt;Build and Run&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cargo build&#xA;espflash flash target/xtensa-esp32-espidf/debug/blink --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
