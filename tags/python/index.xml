<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/python/</link>
    <description>Recent content in Python on Lean Deep Tech blog</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 23 Feb 2026 22:19:00 +0000</lastBuildDate>
    <atom:link href="https://leandeep.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premier limit order avec Nautilus trader sur Binance</title>
      <link>https://leandeep.com/premier-limit-order-avec-nautilus-trader-sur-binance/</link>
      <pubDate>Mon, 23 Feb 2026 22:19:00 +0000</pubDate>
      <guid>https://leandeep.com/premier-limit-order-avec-nautilus-trader-sur-binance/</guid>
      <description>&lt;p&gt;Dans cet article, j&amp;rsquo;approfondis l&amp;rsquo;adapter Binance √©crit en Rust de Nautilus trader pour pouvoir me connecter au testnet de Binance pour r√©aliser un limit order.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;acc√®s-au-testnet-de-binance&#34;&gt;Acc√®s au testnet de Binance&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Data tester&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;L&amp;rsquo;adapter existant ne supporte pas le testnet.&lt;/p&gt;&#xA;&lt;p&gt;Cr√©er une API key sur &lt;a href=&#34;https://testnet.binance.vision/key/register&#34;&gt;https://testnet.binance.vision/key/register&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;openssl genrsa -out test-prv-key.pem 2048&#xA;openssl rsa -in test-prv-key.pem -pubout -outform PEM -out test-pub-key.pem&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Je pr√©conise de cr√©er une autre example dans l&amp;rsquo;adapter binance: &lt;code&gt;node_data_tester_testnet.rs&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;export BINANCE_API_KEY=&amp;#34;API_KEY_FROM_BINANCE_TESTNET_WEBSITE&amp;#34;&#xA;export BINANCE_API_SECRET=&amp;#34;$(cat /path/to/test-prv-key.pem)&amp;#34;&#xA;cargo run --release --example binance-spot-data-tester-testnet --package nautilus-binance&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;R√©sultat:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Premiers pas avec Nautilus trader</title>
      <link>https://leandeep.com/premiers-pas-avec-nautilus-trader/</link>
      <pubDate>Mon, 23 Feb 2026 21:19:00 +0000</pubDate>
      <guid>https://leandeep.com/premiers-pas-avec-nautilus-trader/</guid>
      <description>&lt;p&gt;Dans cet article, je parcours quelques adapters de Nautilus trader √©crits en Rust pour r√©cup√©rer les donn√©es en temps r√©el sur diff√©rents exchanges. Mon objectif est de r√©√©crire des bots de trading en Rust et de voir si Nautilus trader pourrait m&amp;rsquo;aider √† avancer plus vite que si je d√©marrais from scratch.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;acc√®s-aux-donn√©es-dexchanges&#34;&gt;Acc√®s aux donn√©es d&amp;rsquo;exchanges&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Binance&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Pour utilise l&amp;rsquo;adapter Binance, il faut g√©n√©rer une API key &lt;code&gt;Ed25519&lt;/code&gt;. On fournit √† Binance un API secret et Binance fournit un API key.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Analyse du projet nautilus trader</title>
      <link>https://leandeep.com/analyse-du-projet-nautilus-trader/</link>
      <pubDate>Wed, 18 Feb 2026 21:19:00 +0000</pubDate>
      <guid>https://leandeep.com/analyse-du-projet-nautilus-trader/</guid>
      <description>&lt;p&gt;Dans cet article, nous allons voir ce qu&amp;rsquo;est Nautilus Trader et comment l&amp;rsquo;utiliser.&#xA;Je me suis pench√© sur cet outil car je m&amp;rsquo;√©tais fix√© l&amp;rsquo;objectif de r√©-√©crire un bot de trading en Rust avant de m&amp;rsquo;apercevoir qu&amp;rsquo;il y avait d√©j√† cette plateforme open source qui existait et qui contient d√©j√† plus de 17 000 commits.&#xA;Plut√¥t que de r√©inventer la roue, l&amp;rsquo;id√©e est de voir si je peux m&amp;rsquo;approprier cet outil bot pour en faire un bot d&amp;rsquo;arbitage. Cela me permet aussi de me plonger dans un large projet Rust avec bindings pour Python. Et du coup s&amp;rsquo;il manque des features, ce sera avec grand plaisir que je pourrai les coder.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fine-tune Yolo pour d√©tecter un feu</title>
      <link>https://leandeep.com/fine-tune-yolo-pour-d%C3%A9tecter-un-feu/</link>
      <pubDate>Sat, 19 Jul 2025 11:36:00 +0200</pubDate>
      <guid>https://leandeep.com/fine-tune-yolo-pour-d%C3%A9tecter-un-feu/</guid>
      <description>&lt;p&gt;On cr√©e un jupyter notebook:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir yolo-finetune-fire &amp;amp;&amp;amp; cd $_&#xA;touch yolo-finetune.ipynb&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contenu du Notebook&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MY_SECRET_KEY=&amp;#34;...&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;!pip install ultralytics&#xA;!pip install roboflow&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os&#xA;import yaml&#xA;import ultralytics&#xA;import pandas as pd&#xA;from roboflow import Roboflow&#xA;from ultralytics import YOLO&#xA;from IPython.display import Image, display&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contenu Markdown&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;yolov11s.pt vs yolov11n.pt&lt;/p&gt;&#xA;&lt;p&gt;Le &amp;ldquo;s&amp;rdquo; signifie &amp;ldquo;small&amp;rdquo; (petit). Mod√®le plus grand que &amp;ldquo;n&amp;rdquo;, avec plus de couches et de param√®tres. Meilleure pr√©cision, mais plus lent et plus gourmand en ressources que &amp;ldquo;n&amp;rdquo;. yolov11n.pt&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installer Jupyter lab sur Ubuntu 22</title>
      <link>https://leandeep.com/installer-jupyter-lab-sur-ubuntu-22/</link>
      <pubDate>Sat, 19 Jul 2025 10:59:00 +0200</pubDate>
      <guid>https://leandeep.com/installer-jupyter-lab-sur-ubuntu-22/</guid>
      <description>&lt;p&gt;Dans cet article tr√®s court, nous allons voir comment installer Jupyter lab sur Ubuntu 22.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Attention cette installation n&#39;est pas s√©curis√©e. C&#39;est de l&#39;ultra temporaire √† ne surtout pas utiliser en entreprise et encore moins avec des donn√©es de prod.&lt;/code&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;pr√©-requis&#34;&gt;Pr√©-requis&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;miniconda3-3.11-23.5.0-3&lt;/li&gt;&#xA;&lt;li&gt;nvidia-smi pour v√©rifier que vous avez acc√®s √† un GPU&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install notebook jupyterlab jupyter&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jupyter lab --ip=0.0.0.0 --port=8888 --no-browser --allow-root&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Et voil√†, rendez-vous sur &lt;code&gt;http://VOTRE_SERVER:8888/lab?token=MOT_DE_PASSE&lt;/code&gt; pour acc√©der √† Jupyter lab.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installer direnv sur Ubuntu 22</title>
      <link>https://leandeep.com/installer-direnv-sur-ubuntu-22/</link>
      <pubDate>Sat, 19 Jul 2025 10:49:00 +0200</pubDate>
      <guid>https://leandeep.com/installer-direnv-sur-ubuntu-22/</guid>
      <description>&lt;p&gt;Dans cet article tr√®s court, nous allons voir comment installer direnv sur Ubuntu 22.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install direnv&#xA;curl https://pyenv.run | bash&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;&#xA;&lt;p&gt;Ajouter les lignes suivantes dans votre &lt;code&gt;.zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&#xA;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&#xA;eval &amp;#34;$(pyenv init --path)&amp;#34;&#xA;eval &amp;#34;$(pyenv init -)&amp;#34;&#xA;eval &amp;#34;$(direnv hook zsh)&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ex√©cuter &lt;code&gt;soure ~/.zshrc&lt;/code&gt; puis installer un package python de votre choix.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pyenv install 3.11.8&#xA;pyenv global 3.11.8&#xA;&#xA;# Ou &#xA;pyenv install miniconda3-3.11-23.5.0-3&#xA;pyenv global miniconda3-3.11-23.5.0-3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;That&amp;rsquo;s all!&#xA;Vous pouvez maintenant ex√©cuter &lt;code&gt;echo &amp;quot;layout pyenv 3.11.8&amp;quot; &amp;gt;&amp;gt; .envrc&lt;/code&gt; o√π vous voulez&lt;/p&gt;</description>
    </item>
    <item>
      <title>Access Raspberry Pi Camera using Python and OpenCV</title>
      <link>https://leandeep.com/access-raspberry-pi-camera-using-python-and-opencv/</link>
      <pubDate>Mon, 28 Apr 2025 21:55:00 +0200</pubDate>
      <guid>https://leandeep.com/access-raspberry-pi-camera-using-python-and-opencv/</guid>
      <description>&lt;p&gt;In this article we are going to see how to install OpenCV on a Raspberry PI using Bookworm.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Install dependencies on Raspberry Pi&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt update&#xA;sudo apt install python3-picamera2&#xA;sudo apt install libcamera-apps&#xA;sudo apt install python3-opencv&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Install dependencies on Macbook&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install opencv-python numpy&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import cv2&#xA;import numpy as np&#xA;import time&#xA;from datetime import datetime&#xA;import os&#xA;&#xA;# ==========================&#xA;#   CONSTANTS (Configuration)&#xA;# ==========================&#xA;BLUR_SIZE = (7, 7)              # Larger ‚Üí less sensitive (e.g., (7,7) or (9,9))&#xA;THRESHOLD_SENSITIVITY = 50       # Higher ‚Üí less sensitive (e.g., 60, 70)&#xA;MIN_CONTOUR_AREA = 2000          # Higher ‚Üí only detects larger movements&#xA;FRAME_WAIT_TIME = 0.1            # Time to wait between frames (in seconds)&#xA;SAVE_DIR = &amp;#34;captures&amp;#34;            # Directory to save captured images&#xA;&#xA;# ==========================&#xA;#   Camera Initialization&#xA;# ==========================&#xA;def initialize_camera():&#xA;    try:&#xA;        from picamera2 import Picamera2&#xA;        picam2 = Picamera2()&#xA;        config = picam2.create_preview_configuration(main={&amp;#34;format&amp;#34;: &amp;#34;RGB888&amp;#34;, &amp;#34;size&amp;#34;: (640, 480)})&#xA;        picam2.configure(config)&#xA;        picam2.start()&#xA;        time.sleep(2)&#xA;        print(&amp;#34;[INFO] Raspberry Pi camera initialized.&amp;#34;)&#xA;        return picam2, True&#xA;    except ImportError:&#xA;        cap = cv2.VideoCapture(0)&#xA;        if not cap.isOpened():&#xA;            raise Exception(&amp;#34;[ERROR] Cannot open webcam.&amp;#34;)&#xA;        time.sleep(2)&#xA;        print(&amp;#34;[INFO] Webcam initialized.&amp;#34;)&#xA;        return cap, False&#xA;&#xA;# ==========================&#xA;#   Frame Capture&#xA;# ==========================&#xA;def capture_frame(camera, is_picam):&#xA;    if is_picam:&#xA;        return camera.capture_array()&#xA;    else:&#xA;        ret, frame = camera.read()&#xA;        if not ret:&#xA;            raise Exception(&amp;#34;[ERROR] Failed to capture frame.&amp;#34;)&#xA;        return frame&#xA;&#xA;# ==========================&#xA;#   Frame Processing&#xA;# ==========================&#xA;def process_frame(current_frame, previous_frame, is_picam):&#xA;    # Apply Gaussian blur&#xA;    current_blurred = cv2.GaussianBlur(current_frame, BLUR_SIZE, 0)&#xA;    previous_blurred = cv2.GaussianBlur(previous_frame, BLUR_SIZE, 0)&#xA;&#xA;    # Convert to grayscale&#xA;    if is_picam:&#xA;        gray_current = cv2.cvtColor(current_blurred, cv2.COLOR_RGB2GRAY)&#xA;        gray_previous = cv2.cvtColor(previous_blurred, cv2.COLOR_RGB2GRAY)&#xA;    else:&#xA;        gray_current = cv2.cvtColor(current_blurred, cv2.COLOR_BGR2GRAY)&#xA;        gray_previous = cv2.cvtColor(previous_blurred, cv2.COLOR_BGR2GRAY)&#xA;&#xA;    # Compute difference and threshold&#xA;    diff = cv2.absdiff(gray_previous, gray_current)&#xA;    _, thresh = cv2.threshold(diff, THRESHOLD_SENSITIVITY, 255, cv2.THRESH_BINARY)&#xA;    thresh = cv2.dilate(thresh, None, iterations=2)&#xA;&#xA;    return thresh&#xA;&#xA;# ==========================&#xA;#   Movement Detection&#xA;# ==========================&#xA;def detect_movement(thresh):&#xA;    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)&#xA;&#xA;    for contour in contours:&#xA;        if cv2.contourArea(contour) &amp;gt;= MIN_CONTOUR_AREA:&#xA;            return True&#xA;    return False&#xA;&#xA;# ==========================&#xA;#   Save Frame&#xA;# ==========================&#xA;def save_frame(frame, is_picam):&#xA;    now = datetime.now()&#xA;    timestamp = now.strftime(&amp;#34;%Y-%m-%d_%H-%M-%S&amp;#34;)&#xA;    filename = os.path.join(SAVE_DIR, f&amp;#34;capture_{timestamp}.jpg&amp;#34;)&#xA;&#xA;    if is_picam:&#xA;        frame_to_save = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)&#xA;    else:&#xA;        frame_to_save = frame  # Already BGR&#xA;&#xA;    cv2.imwrite(filename, frame_to_save)&#xA;    print(f&amp;#34;[INFO] Image saved: {filename}&amp;#34;)&#xA;&#xA;# ==========================&#xA;#   Main Function&#xA;# ==========================&#xA;def main():&#xA;    os.makedirs(SAVE_DIR, exist_ok=True)&#xA;&#xA;    camera, is_picam = initialize_camera()&#xA;    previous_frame = capture_frame(camera, is_picam)&#xA;&#xA;    print(&amp;#34;[INFO] Surveillance started... (Press Ctrl+C to exit)&amp;#34;)&#xA;&#xA;    try:&#xA;        while True:&#xA;            current_frame = capture_frame(camera, is_picam)&#xA;            thresh = process_frame(current_frame, previous_frame, is_picam)&#xA;&#xA;            if detect_movement(thresh):&#xA;                print(f&amp;#34;[{datetime.now().strftime(&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39;)}] Movement detected!&amp;#34;)&#xA;                save_frame(current_frame, is_picam)&#xA;&#xA;            previous_frame = current_frame.copy()&#xA;            time.sleep(FRAME_WAIT_TIME)&#xA;&#xA;    except KeyboardInterrupt:&#xA;        print(&amp;#34;\n[INFO] Surveillance stopped by the user.&amp;#34;)&#xA;&#xA;    finally:&#xA;        if is_picam:&#xA;            camera.stop()&#xA;        else:&#xA;            camera.release()&#xA;&#xA;# ==========================&#xA;#   Entry Point&#xA;# ==========================&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BLUR_SIZE&lt;/code&gt;: larger ‚Üí less sensitive (e.g., (7,7) or (9,9))&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;THRESHOLD_SENSITIVITY&lt;/code&gt;: higher ‚Üí less sensitive (e.g., 60, 70)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;MIN_CONTOUR_AREA&lt;/code&gt;: higher ‚Üí only detects larger movements&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>H-Bridge L298N with Raspberry Pi and Python</title>
      <link>https://leandeep.com/h-bridge-l298n-with-raspberry-pi-and-python/</link>
      <pubDate>Mon, 28 Apr 2025 21:49:00 +0200</pubDate>
      <guid>https://leandeep.com/h-bridge-l298n-with-raspberry-pi-and-python/</guid>
      <description>&lt;p&gt;In the article we are going to see how to control a H-bridge L298N connected to a Raspberry Pi using Python.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Connect the bridge L298N to the raspberry pi&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/rsapberry-3b-gpio.svg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Connect the pin IN1 of the L298N to GPIO7 (pin 26) of the Raspberry Pi (so GPIO4).&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin IN2 of the L298N to GPIO8 (pin 24) of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin ENA of the L298N to GPIO25 (pin 22) of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin VCC of the L298N to the pin 2 of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin GND of the L298N to the pin 6 of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Install dependency&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Surveiller et red√©marrer un script Python d√®s qu&#39;un fichier est modifi√©</title>
      <link>https://leandeep.com/surveiller-et-red%C3%A9marrer-un-script-python-d%C3%A8s-quun-fichier-est-modifi%C3%A9/</link>
      <pubDate>Sat, 11 Jan 2025 23:32:00 +0200</pubDate>
      <guid>https://leandeep.com/surveiller-et-red%C3%A9marrer-un-script-python-d%C3%A8s-quun-fichier-est-modifi%C3%A9/</guid>
      <description>&lt;p&gt;On peut utiliser watchdog pour surveiller les modifications des fichiers et relancer automatiquement un module/script lorsque des modifications sont d√©tect√©es. Voici un exemple complet:&lt;/p&gt;&#xA;&lt;h2 id=&#34;pr√©-requis&#34;&gt;Pr√©-requis&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;pip install watchdog&lt;/code&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;cr√©er-un-script-de-surveillance&#34;&gt;Cr√©er un script de surveillance&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Tracker un fichier.py&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Cr√©er par exemple un fichier appel√© &lt;code&gt;run_and_reload.py&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import time&#xA;import os&#xA;import sys&#xA;import argparse&#xA;from watchdog.observers import Observer&#xA;from watchdog.events import FileSystemEventHandler&#xA;&#xA;class TargetFileHandler(FileSystemEventHandler):&#xA;    def __init__(self, target_file):&#xA;        self.target_file = os.path.abspath(target_file)&#xA;&#xA;    def on_modified(self, event):&#xA;        if os.path.abspath(event.src_path) == self.target_file:&#xA;            print(f&amp;#34;[MODIFIED] {event.src_path}&amp;#34;)&#xA;&#xA;    def on_deleted(self, event):&#xA;        if os.path.abspath(event.src_path) == self.target_file:&#xA;            print(f&amp;#34;[DELETED] {event.src_path}&amp;#34;)&#xA;&#xA;    def on_created(self, event):&#xA;        if os.path.abspath(event.src_path) == self.target_file:&#xA;            print(f&amp;#34;[CREATED] {event.src_path}&amp;#34;)&#xA;&#xA;def main():&#xA;    parser = argparse.ArgumentParser(description=&amp;#34;Monitor a .py file for changes.&amp;#34;)&#xA;    parser.add_argument(&amp;#34;file&amp;#34;, help=&amp;#34;Path to the .py file to monitor&amp;#34;)&#xA;    parser.add_argument(&amp;#34;-d&amp;#34;, &amp;#34;--directory&amp;#34;, help=&amp;#34;Directory to monitor (default: file&amp;#39;s directory)&amp;#34;)&#xA;&#xA;    args = parser.parse_args()&#xA;&#xA;    file_path = os.path.abspath(args.file)&#xA;&#xA;    if not os.path.isfile(file_path):&#xA;        print(f&amp;#34;Error: File &amp;#39;{file_path}&amp;#39; does not exist.&amp;#34;)&#xA;        sys.exit(1)&#xA;&#xA;    # Use the provided directory or fallback to the file&amp;#39;s directory&#xA;    directory_to_watch = os.path.abspath(args.directory) if args.directory else os.path.dirname(file_path)&#xA;&#xA;    if not os.path.isdir(directory_to_watch):&#xA;        print(f&amp;#34;Error: Directory &amp;#39;{directory_to_watch}&amp;#39; does not exist.&amp;#34;)&#xA;        sys.exit(1)&#xA;&#xA;    event_handler = TargetFileHandler(file_path)&#xA;    observer = Observer()&#xA;    observer.schedule(event_handler, path=directory_to_watch, recursive=False)&#xA;    observer.start()&#xA;&#xA;    print(f&amp;#34;‚è≥ Monitoring: {file_path}&amp;#34;)&#xA;    print(f&amp;#34;üìÅ Watched directory: {directory_to_watch}&amp;#34;)&#xA;    print(&amp;#34;üîî Press Ctrl+C to stop&amp;#34;)&#xA;&#xA;    try:&#xA;        while True:&#xA;            time.sleep(1)&#xA;    except KeyboardInterrupt:&#xA;        observer.stop()&#xA;        print(&amp;#34;\nStopping monitor...&amp;#34;)&#xA;&#xA;    observer.join()&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Usage:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simuler un mode offline pour certains tests Pytest</title>
      <link>https://leandeep.com/simuler-un-mode-offline-pour-certains-tests-pytest/</link>
      <pubDate>Tue, 10 Dec 2024 23:49:00 +0200</pubDate>
      <guid>https://leandeep.com/simuler-un-mode-offline-pour-certains-tests-pytest/</guid>
      <description>&lt;p&gt;Pour certains, cet article peut sembler inutile car ils vous diront qu&amp;rsquo;il suffit de couper le wifi sur son laptop pour ne plus avoir internet. Ce n&amp;rsquo;est pas faux, mais parfois et sans rentrer dans le d√©tail, il n&amp;rsquo;est pas toujours possible de travailler offline pendant des heures.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;Voici donc un tip pour simuler dans des tests unitaires la d√©connexion d&amp;rsquo;internet.&#xA;Il suffit de cr√©er la fixture pytest suivante et de l&amp;rsquo;appeler dans vos tests.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
