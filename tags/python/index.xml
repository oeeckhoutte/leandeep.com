<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/python/</link>
    <description>Recent content in Python on Lean Deep Tech blog</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 19 Jul 2025 11:36:00 +0200</lastBuildDate>
    <atom:link href="https://leandeep.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fine-tune Yolo pour d√©tecter un feu</title>
      <link>https://leandeep.com/fine-tune-yolo-pour-d%C3%A9tecter-un-feu/</link>
      <pubDate>Sat, 19 Jul 2025 11:36:00 +0200</pubDate>
      <guid>https://leandeep.com/fine-tune-yolo-pour-d%C3%A9tecter-un-feu/</guid>
      <description>&lt;p&gt;On cr√©e un jupyter notebook:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir yolo-finetune-fire &amp;amp;&amp;amp; cd $_&#xA;touch yolo-finetune.ipynb&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contenu du Notebook&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MY_SECRET_KEY=&amp;#34;...&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;!pip install ultralytics&#xA;!pip install roboflow&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import os&#xA;import yaml&#xA;import ultralytics&#xA;import pandas as pd&#xA;from roboflow import Roboflow&#xA;from ultralytics import YOLO&#xA;from IPython.display import Image, display&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contenu Markdown&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;yolov11s.pt vs yolov11n.pt&lt;/p&gt;&#xA;&lt;p&gt;Le &amp;ldquo;s&amp;rdquo; signifie &amp;ldquo;small&amp;rdquo; (petit). Mod√®le plus grand que &amp;ldquo;n&amp;rdquo;, avec plus de couches et de param√®tres. Meilleure pr√©cision, mais plus lent et plus gourmand en ressources que &amp;ldquo;n&amp;rdquo;. yolov11n.pt&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installer Jupyter lab sur Ubuntu 22</title>
      <link>https://leandeep.com/installer-jupyter-lab-sur-ubuntu-22/</link>
      <pubDate>Sat, 19 Jul 2025 10:59:00 +0200</pubDate>
      <guid>https://leandeep.com/installer-jupyter-lab-sur-ubuntu-22/</guid>
      <description>&lt;p&gt;Dans cet article tr√®s court, nous allons voir comment installer Jupyter lab sur Ubuntu 22.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Attention cette installation n&#39;est pas s√©curis√©e. C&#39;est de l&#39;ultra temporaire √† ne surtout pas utiliser en entreprise et encore moins avec des donn√©es de prod.&lt;/code&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;pr√©-requis&#34;&gt;Pr√©-requis&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;miniconda3-3.11-23.5.0-3&lt;/li&gt;&#xA;&lt;li&gt;nvidia-smi pour v√©rifier que vous avez acc√®s √† un GPU&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install notebook jupyterlab jupyter&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jupyter lab --ip=0.0.0.0 --port=8888 --no-browser --allow-root&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Et voil√†, rendez-vous sur &lt;code&gt;http://VOTRE_SERVER:8888/lab?token=MOT_DE_PASSE&lt;/code&gt; pour acc√©der √† Jupyter lab.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installer direnv sur Ubuntu 22</title>
      <link>https://leandeep.com/installer-direnv-sur-ubuntu-22/</link>
      <pubDate>Sat, 19 Jul 2025 10:49:00 +0200</pubDate>
      <guid>https://leandeep.com/installer-direnv-sur-ubuntu-22/</guid>
      <description>&lt;p&gt;Dans cet article tr√®s court, nous allons voir comment installer direnv sur Ubuntu 22.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install direnv&#xA;curl https://pyenv.run | bash&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;&#xA;&lt;p&gt;Ajouter les lignes suivantes dans votre &lt;code&gt;.zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;&#xA;export PATH=&amp;#34;$PYENV_ROOT/bin:$PATH&amp;#34;&#xA;eval &amp;#34;$(pyenv init --path)&amp;#34;&#xA;eval &amp;#34;$(pyenv init -)&amp;#34;&#xA;eval &amp;#34;$(direnv hook zsh)&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ex√©cuter &lt;code&gt;soure ~/.zshrc&lt;/code&gt; puis installer un package python de votre choix.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pyenv install 3.11.8&#xA;pyenv global 3.11.8&#xA;&#xA;# Ou &#xA;pyenv install miniconda3-3.11-23.5.0-3&#xA;pyenv global miniconda3-3.11-23.5.0-3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;That&amp;rsquo;s all!&#xA;Vous pouvez maintenant ex√©cuter &lt;code&gt;echo &amp;quot;layout pyenv 3.11.8&amp;quot; &amp;gt;&amp;gt; .envrc&lt;/code&gt; o√π vous voulez&lt;/p&gt;</description>
    </item>
    <item>
      <title>Access Raspberry Pi Camera using Python and OpenCV</title>
      <link>https://leandeep.com/access-raspberry-pi-camera-using-python-and-opencv/</link>
      <pubDate>Mon, 28 Apr 2025 21:55:00 +0200</pubDate>
      <guid>https://leandeep.com/access-raspberry-pi-camera-using-python-and-opencv/</guid>
      <description>&lt;p&gt;In this article we are going to see how to install OpenCV on a Raspberry PI using Bookworm.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Install dependencies on Raspberry Pi&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt update&#xA;sudo apt install python3-picamera2&#xA;sudo apt install libcamera-apps&#xA;sudo apt install python3-opencv&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Install dependencies on Macbook&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install opencv-python numpy&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import cv2&#xA;import numpy as np&#xA;import time&#xA;from datetime import datetime&#xA;import os&#xA;&#xA;# ==========================&#xA;#   CONSTANTS (Configuration)&#xA;# ==========================&#xA;BLUR_SIZE = (7, 7)              # Larger ‚Üí less sensitive (e.g., (7,7) or (9,9))&#xA;THRESHOLD_SENSITIVITY = 50       # Higher ‚Üí less sensitive (e.g., 60, 70)&#xA;MIN_CONTOUR_AREA = 2000          # Higher ‚Üí only detects larger movements&#xA;FRAME_WAIT_TIME = 0.1            # Time to wait between frames (in seconds)&#xA;SAVE_DIR = &amp;#34;captures&amp;#34;            # Directory to save captured images&#xA;&#xA;# ==========================&#xA;#   Camera Initialization&#xA;# ==========================&#xA;def initialize_camera():&#xA;    try:&#xA;        from picamera2 import Picamera2&#xA;        picam2 = Picamera2()&#xA;        config = picam2.create_preview_configuration(main={&amp;#34;format&amp;#34;: &amp;#34;RGB888&amp;#34;, &amp;#34;size&amp;#34;: (640, 480)})&#xA;        picam2.configure(config)&#xA;        picam2.start()&#xA;        time.sleep(2)&#xA;        print(&amp;#34;[INFO] Raspberry Pi camera initialized.&amp;#34;)&#xA;        return picam2, True&#xA;    except ImportError:&#xA;        cap = cv2.VideoCapture(0)&#xA;        if not cap.isOpened():&#xA;            raise Exception(&amp;#34;[ERROR] Cannot open webcam.&amp;#34;)&#xA;        time.sleep(2)&#xA;        print(&amp;#34;[INFO] Webcam initialized.&amp;#34;)&#xA;        return cap, False&#xA;&#xA;# ==========================&#xA;#   Frame Capture&#xA;# ==========================&#xA;def capture_frame(camera, is_picam):&#xA;    if is_picam:&#xA;        return camera.capture_array()&#xA;    else:&#xA;        ret, frame = camera.read()&#xA;        if not ret:&#xA;            raise Exception(&amp;#34;[ERROR] Failed to capture frame.&amp;#34;)&#xA;        return frame&#xA;&#xA;# ==========================&#xA;#   Frame Processing&#xA;# ==========================&#xA;def process_frame(current_frame, previous_frame, is_picam):&#xA;    # Apply Gaussian blur&#xA;    current_blurred = cv2.GaussianBlur(current_frame, BLUR_SIZE, 0)&#xA;    previous_blurred = cv2.GaussianBlur(previous_frame, BLUR_SIZE, 0)&#xA;&#xA;    # Convert to grayscale&#xA;    if is_picam:&#xA;        gray_current = cv2.cvtColor(current_blurred, cv2.COLOR_RGB2GRAY)&#xA;        gray_previous = cv2.cvtColor(previous_blurred, cv2.COLOR_RGB2GRAY)&#xA;    else:&#xA;        gray_current = cv2.cvtColor(current_blurred, cv2.COLOR_BGR2GRAY)&#xA;        gray_previous = cv2.cvtColor(previous_blurred, cv2.COLOR_BGR2GRAY)&#xA;&#xA;    # Compute difference and threshold&#xA;    diff = cv2.absdiff(gray_previous, gray_current)&#xA;    _, thresh = cv2.threshold(diff, THRESHOLD_SENSITIVITY, 255, cv2.THRESH_BINARY)&#xA;    thresh = cv2.dilate(thresh, None, iterations=2)&#xA;&#xA;    return thresh&#xA;&#xA;# ==========================&#xA;#   Movement Detection&#xA;# ==========================&#xA;def detect_movement(thresh):&#xA;    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)&#xA;&#xA;    for contour in contours:&#xA;        if cv2.contourArea(contour) &amp;gt;= MIN_CONTOUR_AREA:&#xA;            return True&#xA;    return False&#xA;&#xA;# ==========================&#xA;#   Save Frame&#xA;# ==========================&#xA;def save_frame(frame, is_picam):&#xA;    now = datetime.now()&#xA;    timestamp = now.strftime(&amp;#34;%Y-%m-%d_%H-%M-%S&amp;#34;)&#xA;    filename = os.path.join(SAVE_DIR, f&amp;#34;capture_{timestamp}.jpg&amp;#34;)&#xA;&#xA;    if is_picam:&#xA;        frame_to_save = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)&#xA;    else:&#xA;        frame_to_save = frame  # Already BGR&#xA;&#xA;    cv2.imwrite(filename, frame_to_save)&#xA;    print(f&amp;#34;[INFO] Image saved: {filename}&amp;#34;)&#xA;&#xA;# ==========================&#xA;#   Main Function&#xA;# ==========================&#xA;def main():&#xA;    os.makedirs(SAVE_DIR, exist_ok=True)&#xA;&#xA;    camera, is_picam = initialize_camera()&#xA;    previous_frame = capture_frame(camera, is_picam)&#xA;&#xA;    print(&amp;#34;[INFO] Surveillance started... (Press Ctrl+C to exit)&amp;#34;)&#xA;&#xA;    try:&#xA;        while True:&#xA;            current_frame = capture_frame(camera, is_picam)&#xA;            thresh = process_frame(current_frame, previous_frame, is_picam)&#xA;&#xA;            if detect_movement(thresh):&#xA;                print(f&amp;#34;[{datetime.now().strftime(&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39;)}] Movement detected!&amp;#34;)&#xA;                save_frame(current_frame, is_picam)&#xA;&#xA;            previous_frame = current_frame.copy()&#xA;            time.sleep(FRAME_WAIT_TIME)&#xA;&#xA;    except KeyboardInterrupt:&#xA;        print(&amp;#34;\n[INFO] Surveillance stopped by the user.&amp;#34;)&#xA;&#xA;    finally:&#xA;        if is_picam:&#xA;            camera.stop()&#xA;        else:&#xA;            camera.release()&#xA;&#xA;# ==========================&#xA;#   Entry Point&#xA;# ==========================&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BLUR_SIZE&lt;/code&gt;: larger ‚Üí less sensitive (e.g., (7,7) or (9,9))&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;THRESHOLD_SENSITIVITY&lt;/code&gt;: higher ‚Üí less sensitive (e.g., 60, 70)&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;MIN_CONTOUR_AREA&lt;/code&gt;: higher ‚Üí only detects larger movements&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>H-Bridge L298N with Raspberry Pi and Python</title>
      <link>https://leandeep.com/h-bridge-l298n-with-raspberry-pi-and-python/</link>
      <pubDate>Mon, 28 Apr 2025 21:49:00 +0200</pubDate>
      <guid>https://leandeep.com/h-bridge-l298n-with-raspberry-pi-and-python/</guid>
      <description>&lt;p&gt;In the article we are going to see how to control a H-bridge L298N connected to a Raspberry Pi using Python.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Connect the bridge L298N to the raspberry pi&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/rsapberry-3b-gpio.svg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Connect the pin IN1 of the L298N to GPIO7 (pin 26) of the Raspberry Pi (so GPIO4).&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin IN2 of the L298N to GPIO8 (pin 24) of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin ENA of the L298N to GPIO25 (pin 22) of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin VCC of the L298N to the pin 2 of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;li&gt;Connect the pin GND of the L298N to the pin 6 of the Raspberry Pi.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Install dependency&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Surveiller et red√©marrer un script Python d√®s qu&#39;un fichier est modifi√©</title>
      <link>https://leandeep.com/surveiller-et-red%C3%A9marrer-un-script-python-d%C3%A8s-quun-fichier-est-modifi%C3%A9/</link>
      <pubDate>Sat, 11 Jan 2025 23:32:00 +0200</pubDate>
      <guid>https://leandeep.com/surveiller-et-red%C3%A9marrer-un-script-python-d%C3%A8s-quun-fichier-est-modifi%C3%A9/</guid>
      <description>&lt;p&gt;On peut utiliser watchdog pour surveiller les modifications des fichiers et relancer automatiquement un module/script lorsque des modifications sont d√©tect√©es. Voici un exemple complet:&lt;/p&gt;&#xA;&lt;h2 id=&#34;pr√©-requis&#34;&gt;Pr√©-requis&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;pip install watchdog&lt;/code&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;cr√©er-un-script-de-surveillance&#34;&gt;Cr√©er un script de surveillance&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Tracker un fichier.py&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Cr√©er par exemple un fichier appel√© &lt;code&gt;run_and_reload.py&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import time&#xA;import os&#xA;import sys&#xA;import argparse&#xA;from watchdog.observers import Observer&#xA;from watchdog.events import FileSystemEventHandler&#xA;&#xA;class TargetFileHandler(FileSystemEventHandler):&#xA;    def __init__(self, target_file):&#xA;        self.target_file = os.path.abspath(target_file)&#xA;&#xA;    def on_modified(self, event):&#xA;        if os.path.abspath(event.src_path) == self.target_file:&#xA;            print(f&amp;#34;[MODIFIED] {event.src_path}&amp;#34;)&#xA;&#xA;    def on_deleted(self, event):&#xA;        if os.path.abspath(event.src_path) == self.target_file:&#xA;            print(f&amp;#34;[DELETED] {event.src_path}&amp;#34;)&#xA;&#xA;    def on_created(self, event):&#xA;        if os.path.abspath(event.src_path) == self.target_file:&#xA;            print(f&amp;#34;[CREATED] {event.src_path}&amp;#34;)&#xA;&#xA;def main():&#xA;    parser = argparse.ArgumentParser(description=&amp;#34;Monitor a .py file for changes.&amp;#34;)&#xA;    parser.add_argument(&amp;#34;file&amp;#34;, help=&amp;#34;Path to the .py file to monitor&amp;#34;)&#xA;    parser.add_argument(&amp;#34;-d&amp;#34;, &amp;#34;--directory&amp;#34;, help=&amp;#34;Directory to monitor (default: file&amp;#39;s directory)&amp;#34;)&#xA;&#xA;    args = parser.parse_args()&#xA;&#xA;    file_path = os.path.abspath(args.file)&#xA;&#xA;    if not os.path.isfile(file_path):&#xA;        print(f&amp;#34;Error: File &amp;#39;{file_path}&amp;#39; does not exist.&amp;#34;)&#xA;        sys.exit(1)&#xA;&#xA;    # Use the provided directory or fallback to the file&amp;#39;s directory&#xA;    directory_to_watch = os.path.abspath(args.directory) if args.directory else os.path.dirname(file_path)&#xA;&#xA;    if not os.path.isdir(directory_to_watch):&#xA;        print(f&amp;#34;Error: Directory &amp;#39;{directory_to_watch}&amp;#39; does not exist.&amp;#34;)&#xA;        sys.exit(1)&#xA;&#xA;    event_handler = TargetFileHandler(file_path)&#xA;    observer = Observer()&#xA;    observer.schedule(event_handler, path=directory_to_watch, recursive=False)&#xA;    observer.start()&#xA;&#xA;    print(f&amp;#34;‚è≥ Monitoring: {file_path}&amp;#34;)&#xA;    print(f&amp;#34;üìÅ Watched directory: {directory_to_watch}&amp;#34;)&#xA;    print(&amp;#34;üîî Press Ctrl+C to stop&amp;#34;)&#xA;&#xA;    try:&#xA;        while True:&#xA;            time.sleep(1)&#xA;    except KeyboardInterrupt:&#xA;        observer.stop()&#xA;        print(&amp;#34;\nStopping monitor...&amp;#34;)&#xA;&#xA;    observer.join()&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    main()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Usage:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simuler un mode offline pour certains tests Pytest</title>
      <link>https://leandeep.com/simuler-un-mode-offline-pour-certains-tests-pytest/</link>
      <pubDate>Tue, 10 Dec 2024 23:49:00 +0200</pubDate>
      <guid>https://leandeep.com/simuler-un-mode-offline-pour-certains-tests-pytest/</guid>
      <description>&lt;p&gt;Pour certains, cet article peut sembler inutile car ils vous diront qu&amp;rsquo;il suffit de couper le wifi sur son laptop pour ne plus avoir internet. Ce n&amp;rsquo;est pas faux, mais parfois et sans rentrer dans le d√©tail, il n&amp;rsquo;est pas toujours possible de travailler offline pendant des heures.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;Voici donc un tip pour simuler dans des tests unitaires la d√©connexion d&amp;rsquo;internet.&#xA;Il suffit de cr√©er la fixture pytest suivante et de l&amp;rsquo;appeler dans vos tests.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Backtester ses strat√©gies de trading avec Backtrader</title>
      <link>https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/</link>
      <pubDate>Fri, 02 Feb 2024 18:10:00 +0000</pubDate>
      <guid>https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/</guid>
      <description>&lt;p&gt;Voici un exemple de code Python permettant de backtester une strat√©gie (ici j&amp;rsquo;en ai cr√©√© une compl√®tement inutile mais cela permet d&amp;rsquo;illustrer mon propose).&lt;/p&gt;&#xA;&lt;p&gt;&lt;br/&gt;&#xA;&lt;strong&gt;Pr√©-requis&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import math&#xA;import pandas as pd&#xA;import backtrader as bt&#xA;import ccxt&#xA;&#xA;# Charger les donn√©es historiques depuis Binance&#xA;exchange = ccxt.binance(&#xA;    {&#xA;        &amp;#34;apiKey&amp;#34;: &amp;#34;&amp;#34;,&#xA;        &amp;#34;secret&amp;#34;: &amp;#34;&amp;#34;,&#xA;    }&#xA;)&#xA;&#xA;symbol = &amp;#34;ETH/USDT&amp;#34;&#xA;timeframe = &amp;#34;1h&amp;#34;&#xA;&#xA;ohlcv = exchange.fetch_ohlcv(symbol, timeframe)&#xA;df = pd.DataFrame(&#xA;    ohlcv, columns=[&amp;#34;timestamp&amp;#34;, &amp;#34;open&amp;#34;, &amp;#34;high&amp;#34;, &amp;#34;low&amp;#34;, &amp;#34;close&amp;#34;, &amp;#34;volume&amp;#34;]&#xA;)&#xA;df[&amp;#34;timestamp&amp;#34;] = pd.to_datetime(df[&amp;#34;timestamp&amp;#34;], unit=&amp;#34;ms&amp;#34;)&#xA;df.set_index(&amp;#34;timestamp&amp;#34;, inplace=True)&#xA;&#xA;&#xA;# D√©finir la strat√©gie&#xA;class MovingAverageCrossStrategy(bt.Strategy):&#xA;    params = (&#xA;        (&amp;#34;short_period&amp;#34;, 20),&#xA;        (&amp;#34;long_period&amp;#34;, 50),&#xA;    )&#xA;&#xA;    def __init__(self):&#xA;        self.short_ma = bt.indicators.SimpleMovingAverage(&#xA;            self.data.close, period=self.params.short_period&#xA;        )&#xA;        self.long_ma = bt.indicators.SimpleMovingAverage(&#xA;            self.data.close, period=self.params.long_period&#xA;        )&#xA;        self.crossover = bt.indicators.CrossOver(self.short_ma, self.long_ma)&#xA;&#xA;    def next(self):&#xA;        if self.crossover &amp;gt; 0:&#xA;            # Signal d&amp;#39;achat&#xA;            self.buy()&#xA;        elif self.crossover &amp;lt; 0:&#xA;            # Signal de vente&#xA;            self.sell()&#xA;&#xA;&#xA;# Convertir les donn√©es pandas en format compr√©hensible par backtrader&#xA;data = bt.feeds.PandasData(dataname=df)&#xA;&#xA;# Configurer le cerveau du backtest&#xA;cerebro = bt.Cerebro()&#xA;cerebro.adddata(data)&#xA;cerebro.addstrategy(MovingAverageCrossStrategy)&#xA;&#xA;# Ajouter un observer pour afficher les gains/pertes&#xA;cerebro.addobserver(bt.observers.Value)&#xA;&#xA;# Param√®tres du backtest&#xA;start_date = pd.to_datetime(&amp;#34;2022-01-01&amp;#34;)&#xA;end_date = pd.to_datetime(&amp;#34;2022-12-31&amp;#34;)&#xA;cerebro.run(stdstats=False, tradehistory=True, fromdate=start_date, todate=end_date)&#xA;&#xA;# Afficher les gains/pertes&#xA;final_portfolio_value = cerebro.broker.getvalue()&#xA;print(f&amp;#34;Capital final: {final_portfolio_value} USDT&amp;#34;)&#xA;cerebro.plot()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/backtrader.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Setup local development environments with direnv and poetry</title>
      <link>https://leandeep.com/setup-local-development-environments-with-direnv-and-poetry/</link>
      <pubDate>Tue, 02 Jan 2024 23:43:00 +0000</pubDate>
      <guid>https://leandeep.com/setup-local-development-environments-with-direnv-and-poetry/</guid>
      <description>&lt;p&gt;In this short article we are going to configure direnv to be able to use poetry smoothly.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;poetry-installation&#34;&gt;Poetry installation&lt;/h2&gt;&#xA;&lt;h2 id=&#34;option-1&#34;&gt;Option 1&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;brew install pipx&#xA;pipx ensurepath&#xA;pipx install poetry&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;option-2-the-option-i-prefer&#34;&gt;Option 2 (The option I prefer)&lt;/h2&gt;&#xA;&lt;p&gt;If you have &lt;code&gt;pyenv&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;p&gt;Select the Python version you want to use:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# for example&#xA;pyenv global 3.11.2&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then add the following line in your &lt;code&gt;~/.zshrc&lt;/code&gt; file:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;eval &amp;#34;$(pyenv init --path)&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally install poetry with a simple &lt;code&gt;pip install poetry&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Utiliser une IP fixe dans son terminal via proxy socks</title>
      <link>https://leandeep.com/utiliser-une-ip-fixe-dans-son-terminal-via-proxy-socks/</link>
      <pubDate>Tue, 05 Sep 2023 23:46:00 +0200</pubDate>
      <guid>https://leandeep.com/utiliser-une-ip-fixe-dans-son-terminal-via-proxy-socks/</guid>
      <description>&lt;p&gt;Voici un tip pour utiliser une IP fixe depuis son terminal quand son FAI ne fournit pas d&amp;rsquo;adresse IP statique. C&amp;rsquo;est le cas par exemple avec Starlink, SFR ou Orange&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;Pour ce faire, il suffit d&amp;rsquo;utiliser un proxy socks. Si vous avez une VM sur le cloud accessible directement via SSH, vous pouvez utiliser les commandes suivantes:&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;Dans un premier onglet de votre terminal ex√©cuter la commande suivante:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -D 6006 -q -C -N user@ip_or_reverse_dns&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Puis dans un second onglet:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
