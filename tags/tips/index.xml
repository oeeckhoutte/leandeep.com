<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tips on Bienvenue sur le site de Lean Deep</title>
    <link>https://leandeep.com/tags/tips/</link>
    <description>Recent content in tips on Bienvenue sur le site de Lean Deep</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 04 Jul 2020 21:20:04 -0700</lastBuildDate>
    
	<atom:link href="https://leandeep.com/tags/tips/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mocker en 1 minute les appels vers des services externes</title>
      <link>https://leandeep.com/tips/mocker-en-1-minute-les-appels-vers-des-services-externes/</link>
      <pubDate>Sat, 04 Jul 2020 21:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/mocker-en-1-minute-les-appels-vers-des-services-externes/</guid>
      <description>Que ce soit pour du dévelopement ou pour exécuter des tests ou autres, il est très fréquent de vouloir mocker les appels vers des services externes. Si vous utilisez le module requests dans votre projet vous pouvez tout simplement ajouter le module requests_cache pour créer des bouchons. En effet, ce dernier va mettre en cache (dans une base de données sqlite) toutes les réponses aux requêtes faites par requests.
 Mise en place Bien sûr, on install le module: pip install requests_cache.</description>
    </item>
    
    <item>
      <title>Comparaison de strings et logique floue</title>
      <link>https://leandeep.com/tips/logique-flou-dans-comparaison-de-strings/</link>
      <pubDate>Thu, 16 Jan 2020 16:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/logique-flou-dans-comparaison-de-strings/</guid>
      <description>Pour implémenter dans la logique floue pour comparer deux strings, on peut utiliser la distance de Levenshtein.
Voici le code permettant de calculer cette distance. Rien de particulier, on retrouve partout ce code sur internet.
import numpy as np def levenshtein_ratio_and_distance(s, t, ratio_calc = False): &amp;quot;&amp;quot;&amp;quot; levenshtein_ratio_and_distance: Calculates levenshtein distance between two strings. If ratio_calc = True, the function computes the levenshtein distance ratio of similarity between two strings For all i and j, distance[i,j] will contain the Levenshtein distance between the first i characters of s and the first j characters of t &amp;quot;&amp;quot;&amp;quot; # Initialize matrix of zeros rows = len(s)+1 cols = len(t)+1 distance = np.</description>
    </item>
    
    <item>
      <title>Eviter les if ou try/except avec les dictionnaires</title>
      <link>https://leandeep.com/tips/handle-keyerrors-dans-les-dict-avec-defaultdict/</link>
      <pubDate>Thu, 16 Jan 2020 01:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/handle-keyerrors-dans-les-dict-avec-defaultdict/</guid>
      <description>Manipuler des dictionnaires Python est facile. Pour les transformer on peut utiliser des dict comprehension. Par exemple, pour inverser un dictionnaire on peut le faire en une ligne de code.
prenoms = {&#39;titi&#39;: 1, &#39;tata&#39;: 2, &#39;toto&#39;: 3} invert_prenoms = {v: k for k, v in prenoms.iteritems()} print(invert_prenoms) {1: &#39;titi&#39;, 2: &#39;tata&#39;, 3: &#39;toto&#39;} Pour sélectionner une valeur à partir d&#39;une clé, on peut
 soit tester si une clé existe dans le dict ou catcher l&#39;exception KeyError avec try/except ou on peut utiliser un defaultdict, ce qui permet d&#39;avoir du code plus propre, et plus facilement testable.</description>
    </item>
    
    <item>
      <title>Slicer de manière Pythonique un set</title>
      <link>https://leandeep.com/tips/slicer-un-set-de-maniere-pythonique/</link>
      <pubDate>Wed, 15 Jan 2020 15:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/slicer-un-set-de-maniere-pythonique/</guid>
      <description>Ce tip décrit comment slicer (découper) un set de manière Pythonique.
Les sets sont des iterables. On peut donc utiliser la méthode itertools.islice qui va nous permettre de créer un iterator construit à partir d&#39;un sous-ensemble du set de départ.
import itertools prenoms_list = [&#39;titi&#39;, &#39;tata&#39;, &#39;totot&#39;, &#39;titi&#39;] prenoms_set = set(prenoms_list) small_prenoms_set = set(itertools.islice(prenoms_set, 2)) </description>
    </item>
    
    <item>
      <title>Utiliser zip pour itérer sur deux listes</title>
      <link>https://leandeep.com/tips/utiliser-zip-pour-iterer-sur-deux-listes/</link>
      <pubDate>Tue, 14 Jan 2020 21:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/utiliser-zip-pour-iterer-sur-deux-listes/</guid>
      <description>La bonne approche pour itérer sur deux listes est de créer deux variables, par exemple liste_un et liste_deux et d&#39;utiliser zip en passant en paramètre les 2 variables.
Anti-pattern (Pas bien!) nombres = [1, 2, 3] prenoms = [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;] for idx in range(len(nombres)): print(nombres[idx], prenoms[idx]) Bonne pratique (Bien!) Dans les 2 cas, le résultat est identique à savoir:
1 titi 2 tata 3 toto Mais voici une manière plus Pythonique d&#39;itérer sur ces 2 listes.</description>
    </item>
    
    <item>
      <title>Utiliser une boucle non Pythonique</title>
      <link>https://leandeep.com/tips/utiliser-une-boucle-non-pythonique/</link>
      <pubDate>Sat, 11 Jan 2020 21:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/utiliser-une-boucle-non-pythonique/</guid>
      <description>Pour accéder aux éléments d&#39;une liste et afficher l&#39;index des éléments, il vaut mieux privilégier l&#39;utilisation d&#39;enumerate() sur la liste plutôt que de créer une boucle et d&#39;incrémenter la valeur de l&#39;index.
Anti-pattern (Pas bien!) prenoms = [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;] for idx in range(0, len(prenoms)): prenom = l[idx] print(idx, prenom) Bonne pratique (Bien!) Voici la manière plus Pythonique d&#39;itérérer sur une liste.
prenoms = [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;] for idx, prenom in enumerate(prenoms): print(idx, prenom) </description>
    </item>
    
    <item>
      <title>Demander Pardon plutôt que la permission</title>
      <link>https://leandeep.com/tips/demander-pardon-plutot-que-la-permission/</link>
      <pubDate>Sat, 04 Jan 2020 21:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/demander-pardon-plutot-que-la-permission/</guid>
      <description>La communauté Python utilise le coding style appelé EAFP (Easier to Ask for Forgiveness than Permission) au lieu du style LBYL (Look Before You Leap). Ce coding style suppose que les fichiers et variables existent. En d&#39;autres termes, plutôt que de tester toutes les pré-conditions, les problèmes éventuels sont &amp;ldquo;catchés&amp;rdquo; comme des exceptions. EAFP est plus pertinent que LBYL car il est presque impossible d&#39;anticiper tous les problèmes. Le code Python est donc généralement plus concis, plus clair et rempli de try except.</description>
    </item>
    
    <item>
      <title>Différence entre append et extend</title>
      <link>https://leandeep.com/tips/difference-entre-list-append-et-extend/</link>
      <pubDate>Wed, 13 Feb 2019 21:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/difference-entre-list-append-et-extend/</guid>
      <description>Append Ajoute un object en bout de liste:
prenoms = [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;] prenoms.append([&amp;quot;tete&amp;quot;, &amp;quot;tutu&amp;quot;]) print(prenoms) Résultat: [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;, [&amp;quot;tete&amp;quot;, &amp;quot;tutu&amp;quot;]]
 Extend Étend la liste en ajoutant les éléments d&#39;un itérable
prenoms = [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;] prenoms.extend([&amp;quot;tete&amp;quot;, &amp;quot;tutu&amp;quot;]) print(prenoms) Résultat: [&amp;quot;titi&amp;quot;, &amp;quot;tata&amp;quot;, &amp;quot;toto&amp;quot;, &amp;quot;tete&amp;quot;, &amp;quot;tutu&amp;quot;]</description>
    </item>
    
    <item>
      <title>Convertir un type float en type string avec n decimals</title>
      <link>https://leandeep.com/tips/f-string-float-to-string-avec-2-decimals/</link>
      <pubDate>Sat, 16 Jun 2018 21:20:04 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/f-string-float-to-string-avec-2-decimals/</guid>
      <description>Petit tip très rapide qui explique comment convertir un nombre décimal de type float en type string tout en gardant n chiffres après la virgule.
La conversion peut se faire directement avec les f-strings.
price = float(1000) print(type(price)) new_price = f&amp;quot;{price:.2f}&amp;quot; print(new_price) print(type(new_price)) </description>
    </item>
    
    <item>
      <title>Eviter les variables temporaires pour intervertir 2 variables</title>
      <link>https://leandeep.com/tips/eviter-les-variables-temporaires-pour-intervertir-2-variables/</link>
      <pubDate>Tue, 05 Jun 2018 22:12:03 -0700</pubDate>
      
      <guid>https://leandeep.com/tips/eviter-les-variables-temporaires-pour-intervertir-2-variables/</guid>
      <description>En Python, il n&#39;est pas nécessaire d&#39;utiliser une variable temporaire pour intervertir le contenu de 2 variables.
Anti-pattern (Pas bien!) enfant_1 = &amp;quot;riri&amp;quot; enfant_2 = &amp;quot;fifi&amp;quot; temp = enfant_1 enfant_2 = enfant_1 enfant_1 = temp  Bonne pratique (Bien!) enfant_1 = &amp;quot;riri&amp;quot; enfant_2 = &amp;quot;fifi&amp;quot; (enfant_1, enfant_2) = (enfant_2, enfant_1) </description>
    </item>
    
  </channel>
</rss>