<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AlgoTrading on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/algotrading/</link>
    <description>Recent content in AlgoTrading on Lean Deep Tech blog</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 18 Feb 2026 21:19:00 +0000</lastBuildDate>
    <atom:link href="https://leandeep.com/tags/algotrading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Analyse du projet nautilus trader</title>
      <link>https://leandeep.com/analyse-du-projet-nautilus-trader/</link>
      <pubDate>Wed, 18 Feb 2026 21:19:00 +0000</pubDate>
      <guid>https://leandeep.com/analyse-du-projet-nautilus-trader/</guid>
      <description>&lt;p&gt;Dans cet article, nous allons voir ce qu&amp;rsquo;est Nautilus Trader et comment l&amp;rsquo;utiliser.&#xA;Je me suis penché sur cet outil car je m&amp;rsquo;étais fixé l&amp;rsquo;objectif de ré-écrire un bot de trading en Rust avant de m&amp;rsquo;apercevoir qu&amp;rsquo;il y avait déjà cette plateforme open source qui existait et qui contient déjà plus de 17 000 commits.&#xA;Plutôt que de réinventer la roue, l&amp;rsquo;idée est de voir si je peux m&amp;rsquo;approprier cet outil bot pour en faire un bot d&amp;rsquo;arbitage. Cela me permet aussi de me plonger dans un large projet Rust avec bindings pour Python. Et du coup s&amp;rsquo;il manque des features, ce sera avec grand plaisir que je pourrai les coder.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Backtester ses stratégies de trading avec Backtrader</title>
      <link>https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/</link>
      <pubDate>Fri, 02 Feb 2024 18:10:00 +0000</pubDate>
      <guid>https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/</guid>
      <description>&lt;p&gt;Voici un exemple de code Python permettant de backtester une stratégie (ici j&amp;rsquo;en ai créé une complètement inutile mais cela permet d&amp;rsquo;illustrer mon propose).&lt;/p&gt;&#xA;&lt;p&gt;&lt;br/&gt;&#xA;&lt;strong&gt;Pré-requis&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import math&#xA;import pandas as pd&#xA;import backtrader as bt&#xA;import ccxt&#xA;&#xA;# Charger les données historiques depuis Binance&#xA;exchange = ccxt.binance(&#xA;    {&#xA;        &amp;#34;apiKey&amp;#34;: &amp;#34;&amp;#34;,&#xA;        &amp;#34;secret&amp;#34;: &amp;#34;&amp;#34;,&#xA;    }&#xA;)&#xA;&#xA;symbol = &amp;#34;ETH/USDT&amp;#34;&#xA;timeframe = &amp;#34;1h&amp;#34;&#xA;&#xA;ohlcv = exchange.fetch_ohlcv(symbol, timeframe)&#xA;df = pd.DataFrame(&#xA;    ohlcv, columns=[&amp;#34;timestamp&amp;#34;, &amp;#34;open&amp;#34;, &amp;#34;high&amp;#34;, &amp;#34;low&amp;#34;, &amp;#34;close&amp;#34;, &amp;#34;volume&amp;#34;]&#xA;)&#xA;df[&amp;#34;timestamp&amp;#34;] = pd.to_datetime(df[&amp;#34;timestamp&amp;#34;], unit=&amp;#34;ms&amp;#34;)&#xA;df.set_index(&amp;#34;timestamp&amp;#34;, inplace=True)&#xA;&#xA;&#xA;# Définir la stratégie&#xA;class MovingAverageCrossStrategy(bt.Strategy):&#xA;    params = (&#xA;        (&amp;#34;short_period&amp;#34;, 20),&#xA;        (&amp;#34;long_period&amp;#34;, 50),&#xA;    )&#xA;&#xA;    def __init__(self):&#xA;        self.short_ma = bt.indicators.SimpleMovingAverage(&#xA;            self.data.close, period=self.params.short_period&#xA;        )&#xA;        self.long_ma = bt.indicators.SimpleMovingAverage(&#xA;            self.data.close, period=self.params.long_period&#xA;        )&#xA;        self.crossover = bt.indicators.CrossOver(self.short_ma, self.long_ma)&#xA;&#xA;    def next(self):&#xA;        if self.crossover &amp;gt; 0:&#xA;            # Signal d&amp;#39;achat&#xA;            self.buy()&#xA;        elif self.crossover &amp;lt; 0:&#xA;            # Signal de vente&#xA;            self.sell()&#xA;&#xA;&#xA;# Convertir les données pandas en format compréhensible par backtrader&#xA;data = bt.feeds.PandasData(dataname=df)&#xA;&#xA;# Configurer le cerveau du backtest&#xA;cerebro = bt.Cerebro()&#xA;cerebro.adddata(data)&#xA;cerebro.addstrategy(MovingAverageCrossStrategy)&#xA;&#xA;# Ajouter un observer pour afficher les gains/pertes&#xA;cerebro.addobserver(bt.observers.Value)&#xA;&#xA;# Paramètres du backtest&#xA;start_date = pd.to_datetime(&amp;#34;2022-01-01&amp;#34;)&#xA;end_date = pd.to_datetime(&amp;#34;2022-12-31&amp;#34;)&#xA;cerebro.run(stdstats=False, tradehistory=True, fromdate=start_date, todate=end_date)&#xA;&#xA;# Afficher les gains/pertes&#xA;final_portfolio_value = cerebro.broker.getvalue()&#xA;print(f&amp;#34;Capital final: {final_portfolio_value} USDT&amp;#34;)&#xA;cerebro.plot()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/backtrader.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Créer un dataset avec les données Binance OHLCV pour réaliser des backtests</title>
      <link>https://leandeep.com/cr%C3%A9er-un-dataset-avec-les-donn%C3%A9es-binance-ohlcv-pour-r%C3%A9aliser-des-backtests/</link>
      <pubDate>Fri, 27 Jan 2023 10:49:00 +0200</pubDate>
      <guid>https://leandeep.com/cr%C3%A9er-un-dataset-avec-les-donn%C3%A9es-binance-ohlcv-pour-r%C3%A9aliser-des-backtests/</guid>
      <description>&lt;p&gt;Sans utiliser la librairie CCTX dont j&amp;rsquo;ai parlé &lt;a href=&#34;https://leandeep.com/retourner-un-dataframe-ohlcv-des-tickers-binance-%C3%A0-partir-de-cctx/&#34;&gt;dans l&amp;rsquo;article&lt;/a&gt;, voici comment récupérer directement les données OHLCV depuis l&amp;rsquo;API de Binance:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import requests&#xA;import datetime&#xA;import pandas as pd&#xA;import numpy as np&#xA;&#xA;start_date = &amp;#34;2022-01-01&amp;#34;&#xA;end_date = &amp;#34;2022-01-31&amp;#34;&#xA;interval = &amp;#34;1m&amp;#34;&#xA;symbol = &amp;#34;BTCUSDT&amp;#34;&#xA;&#xA;&#xA;def get_binance_data(&#xA;    ticker: str,&#xA;    interval: str = &amp;#34;4h&amp;#34;,&#xA;    limit: int = 500,&#xA;    start: str = &amp;#34;2018-01-01 00:00:00&amp;#34;,&#xA;) -&amp;gt; pd.DataFrame:&#xA;    &amp;#34;&amp;#34;&amp;#34;Get X (limit) OHLCV entries from Binance&amp;#34;&amp;#34;&amp;#34;&#xA;    columns = [&#xA;        &amp;#34;open_time&amp;#34;,&#xA;        &amp;#34;open&amp;#34;,&#xA;        &amp;#34;high&amp;#34;,&#xA;        &amp;#34;low&amp;#34;,&#xA;        &amp;#34;close&amp;#34;,&#xA;        &amp;#34;volume&amp;#34;,&#xA;        &amp;#34;close_time&amp;#34;,&#xA;        &amp;#34;qav&amp;#34;,&#xA;        &amp;#34;num_trades&amp;#34;,&#xA;        &amp;#34;taker_base_vol&amp;#34;,&#xA;        &amp;#34;taker_quote_vol&amp;#34;,&#xA;        &amp;#34;ignore&amp;#34;,&#xA;    ]&#xA;    start = int(datetime.datetime.timestamp(pd.to_datetime(start)) * 1000)&#xA;    base_url = &amp;#34;https://www.binance.com/api/v3/klines&amp;#34;&#xA;    query_params = (&#xA;        f&amp;#34;?symbol={ticker}&amp;amp;interval={interval}&amp;amp;limit={limit}&amp;amp;startTime={start}&amp;#34;&#xA;    )&#xA;    url = base_url + query_params&#xA;    data = pd.DataFrame(&#xA;        requests.get(url).json(), columns=columns, dtype=np.float&#xA;    )&#xA;    data.index = [&#xA;        pd.to_datetime(x, unit=&amp;#34;ms&amp;#34;).strftime(&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;)&#xA;        for x in data.open_time&#xA;    ]&#xA;    use_cols = [&#xA;        &amp;#34;open&amp;#34;,&#xA;        &amp;#34;high&amp;#34;,&#xA;        &amp;#34;low&amp;#34;,&#xA;        &amp;#34;close&amp;#34;,&#xA;        &amp;#34;volume&amp;#34;,&#xA;        &amp;#34;qav&amp;#34;,&#xA;        &amp;#34;num_trades&amp;#34;,&#xA;        &amp;#34;taker_base_vol&amp;#34;,&#xA;        &amp;#34;taker_quote_vol&amp;#34;,&#xA;    ]&#xA;    data = data[use_cols]&#xA;    return data&#xA;&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    df = get_binance_data(&amp;#34;BTCUSDT&amp;#34;, &amp;#34;1m&amp;#34;)&#xA;    print(df.head())&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&#xA;Résultat:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Retourner un dataframe OHLCV des tickers Binance à partir de CCTX</title>
      <link>https://leandeep.com/retourner-un-dataframe-ohlcv-des-tickers-binance-%C3%A0-partir-de-cctx/</link>
      <pubDate>Sat, 14 Jan 2023 07:00:00 +0200</pubDate>
      <guid>https://leandeep.com/retourner-un-dataframe-ohlcv-des-tickers-binance-%C3%A0-partir-de-cctx/</guid>
      <description>&lt;p&gt;Petit tip du jour de minutes. Voici comment convertir les données OHLCV de Binance obtenues grâce à CCTX en dataframe.&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import ccxt&#xA;import calendar&#xA;from datetime import datetime&#xA;import pandas as pd&#xA;import numpy as np&#xA;from typing import List&#xA;&#xA;binance = ccxt.binance()&#xA;&#xA;&#xA;def min_ohlcv(dt: datetime, pair: str, limit: int) -&amp;gt; list:&#xA;    # UTC native object&#xA;    since = calendar.timegm(dt.utctimetuple()) * 1000&#xA;    ohlcv1 = binance.fetch_ohlcv(&#xA;        symbol=pair, timeframe=&amp;#34;1m&amp;#34;, since=since, limit=limit&#xA;    )&#xA;    ohlcv2 = binance.fetch_ohlcv(&#xA;        symbol=pair, timeframe=&amp;#34;1m&amp;#34;, since=since, limit=limit&#xA;    )&#xA;    ohlcv = ohlcv1 + ohlcv2&#xA;    return ohlcv&#xA;&#xA;&#xA;def ohlcv(dt: List[str], pair: str, period: str = &amp;#34;1d&amp;#34;) -&amp;gt; pd.DataFrame:&#xA;    ohlcv = []&#xA;    limit = 1000&#xA;    if period == &amp;#34;1m&amp;#34;:&#xA;        limit = 720&#xA;    elif period == &amp;#34;1d&amp;#34;:&#xA;        limit = 365&#xA;    elif period == &amp;#34;1h&amp;#34;:&#xA;        limit = 24&#xA;    elif period == &amp;#34;5m&amp;#34;:&#xA;        limit = 288&#xA;    for i in dt:&#xA;        start_dt = datetime.strptime(i, &amp;#34;%Y%m%d&amp;#34;)&#xA;        since = calendar.timegm(start_dt.utctimetuple()) * 1000&#xA;        if period == &amp;#34;1m&amp;#34;:&#xA;            ohlcv.extend(min_ohlcv(start_dt, pair, limit))&#xA;        else:&#xA;            ohlcv.extend(&#xA;                binance.fetch_ohlcv(&#xA;                    symbol=pair, timeframe=period, since=since, limit=limit&#xA;                )&#xA;            )&#xA;    df = pd.DataFrame(&#xA;        ohlcv,&#xA;        columns=[&amp;#34;Date&amp;#34;, &amp;#34;Open&amp;#34;, &amp;#34;High&amp;#34;, &amp;#34;Low&amp;#34;, &amp;#34;Close&amp;#34;, &amp;#34;Volume&amp;#34;],&#xA;    )&#xA;    df[&amp;#34;Date&amp;#34;] = [&#xA;        datetime.fromtimestamp(float(time) / 1000) for time in df[&amp;#34;Date&amp;#34;]&#xA;    ]&#xA;    df[&amp;#34;Open&amp;#34;] = df[&amp;#34;Open&amp;#34;].astype(np.float64)&#xA;    df[&amp;#34;High&amp;#34;] = df[&amp;#34;High&amp;#34;].astype(np.float64)&#xA;    df[&amp;#34;Low&amp;#34;] = df[&amp;#34;Low&amp;#34;].astype(np.float64)&#xA;    df[&amp;#34;Close&amp;#34;] = df[&amp;#34;Close&amp;#34;].astype(np.float64)&#xA;    df[&amp;#34;Volume&amp;#34;] = df[&amp;#34;Volume&amp;#34;].astype(np.float64)&#xA;    df.set_index(&amp;#34;Date&amp;#34;, inplace=True)&#xA;    return df&#xA;&#xA;&#xA;dt = [&amp;#34;20190101&amp;#34;, &amp;#34;20200101&amp;#34;]&#xA;df = ohlcv(dt, &amp;#34;BTC/USDT&amp;#34;, &amp;#34;1m&amp;#34;)&#xA;print(df.head())&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Résultat:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Afficher les 500 dernières bougies d&#39;une paire crypto de Binance</title>
      <link>https://leandeep.com/afficher-les-500-derni%C3%A8res-bougies-dune-paire-crypto-de-binance/</link>
      <pubDate>Thu, 05 Jan 2023 07:00:00 +0200</pubDate>
      <guid>https://leandeep.com/afficher-les-500-derni%C3%A8res-bougies-dune-paire-crypto-de-binance/</guid>
      <description>&lt;p&gt;Petit tip du jour. Voici comment afficher, en moins 2 minutes, l&amp;rsquo;évolution du cours d&amp;rsquo;une paire crypto présente sur Binance.&lt;/p&gt;&#xA;&lt;p&gt;Installer les packages &lt;code&gt;cctx&lt;/code&gt; et &lt;code&gt;plotly&lt;/code&gt; puis créer un fichier contenant le code suivant:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import ccxt&#xA;from datetime import datetime&#xA;import plotly.graph_objects as go&#xA;&#xA;&#xA;def run():&#xA;    binance = ccxt.binance()&#xA;    trading_pair = &amp;#34;BTC/USDT&amp;#34;&#xA;    candles = binance.fetch_ohlcv(trading_pair, &amp;#34;1d&amp;#34;)&#xA;&#xA;    dates = []&#xA;    open_data = []&#xA;    high_data = []&#xA;    low_data = []&#xA;    close_data = []&#xA;&#xA;    for candle in candles:&#xA;        dates.append(&#xA;            datetime.fromtimestamp(candle[0] / 1000.0).strftime(&#xA;                &amp;#34;%Y-%m-%d %H:%M:%S.%f&amp;#34;&#xA;            )&#xA;        )&#xA;        open_data.append(candle[1])&#xA;        high_data.append(candle[2])&#xA;        low_data.append(candle[3])&#xA;        close_data.append(candle[4])&#xA;&#xA;    fig = go.Figure(&#xA;        data=[&#xA;            go.Candlestick(&#xA;                x=dates,&#xA;                open=open_data,&#xA;                high=high_data,&#xA;                low=low_data,&#xA;                close=close_data,&#xA;            )&#xA;        ]&#xA;    )&#xA;    fig.show()&#xA;&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    run()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;p&gt;Résultat:&#xA;&lt;img src=&#34;https://leandeep.com/images/plotly-btc-usdt.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cointégration vs Corrélation en trading</title>
      <link>https://leandeep.com/coint%C3%A9gration-vs-corr%C3%A9lation-en-trading/</link>
      <pubDate>Tue, 03 Jan 2023 07:00:00 +0200</pubDate>
      <guid>https://leandeep.com/coint%C3%A9gration-vs-corr%C3%A9lation-en-trading/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Miser sur la corrélation entre différents assets pour faire du pair trading est une mauvaise idée. Il vaut mieux miser sur la cointégration.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;corrélation-vs-cointégration&#34;&gt;Corrélation vs Cointégration&lt;/h2&gt;&#xA;&lt;p&gt;La cointégration est une relation statistique entre deux variables qui évoluent de manière similaire à long terme. Cela signifie que si l&amp;rsquo;une des variables change, l&amp;rsquo;autre suivra également cette tendance sur une période de temps prolongée.&lt;/p&gt;&#xA;&lt;p&gt;La corrélation, en revanche, mesure simplement la relation entre deux variables à un moment donné. Si deux variables sont corrélées, cela signifie qu&amp;rsquo;elles varient de manière similaire, mais cela ne garantit pas qu&amp;rsquo;elles continueront de le faire à long terme.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Data Version Control pour vos projets data ou algo-trading</title>
      <link>https://leandeep.com/data-version-control-pour-vos-projets-data-ou-algo-trading/</link>
      <pubDate>Mon, 02 Jan 2023 12:00:00 +0200</pubDate>
      <guid>https://leandeep.com/data-version-control-pour-vos-projets-data-ou-algo-trading/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Dans cet article, nous allons voir comment versionner nos datasets et notre code. Les datasets ne seront pas stockés sur git car cet outil n&amp;rsquo;est pas fait pour stocker des fichiers volumineux. Il faut donc stocker les données ailleurs. Ici je vais les stocker sur Google Drive. DVC (Data Version Control) va permettre de versionner les data en créant une référence (un hash) qui sera stocké dans le commit git. C&amp;rsquo;est simple mais excessivement efficace.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Afficher les spreads des produits dérivés dans Tradingview</title>
      <link>https://leandeep.com/afficher-les-spreads-des-produits-d%C3%A9riv%C3%A9s-dans-tradingview/</link>
      <pubDate>Wed, 24 Nov 2021 19:49:00 +0200</pubDate>
      <guid>https://leandeep.com/afficher-les-spreads-des-produits-d%C3%A9riv%C3%A9s-dans-tradingview/</guid>
      <description>&lt;p&gt;Aujourd&amp;rsquo;hui j&amp;rsquo;écris mon premier article sur le trading. J&amp;rsquo;avais déjà écrit un article sur la finance en parlant d&amp;rsquo;un outil que j&amp;rsquo;avais construit pour suivre les mouvements des fonds d&amp;rsquo;investissement via le RPA (Robotic Process Automation) mais jamais sur le trading.&lt;/p&gt;&#xA;&lt;p&gt;Nous allons voir comment afficher les spreads dans Tradingview en construisant son propre indicateur EMA (Exponential Moving Average) sur 13 périodes. Voici la démarche à suivre à travers cette vidéo.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
