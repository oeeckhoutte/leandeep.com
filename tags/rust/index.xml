<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/rust/</link>
    <description>Recent content in Rust on Lean Deep Tech blog</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 23 Feb 2026 22:19:00 +0000</lastBuildDate>
    <atom:link href="https://leandeep.com/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premier limit order avec Nautilus trader sur Binance</title>
      <link>https://leandeep.com/premier-limit-order-avec-nautilus-trader-sur-binance/</link>
      <pubDate>Mon, 23 Feb 2026 22:19:00 +0000</pubDate>
      <guid>https://leandeep.com/premier-limit-order-avec-nautilus-trader-sur-binance/</guid>
      <description>&lt;p&gt;Dans cet article, j&amp;rsquo;approfondis l&amp;rsquo;adapter Binance écrit en Rust de Nautilus trader pour pouvoir me connecter au testnet de Binance pour réaliser un limit order.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;accès-au-testnet-de-binance&#34;&gt;Accès au testnet de Binance&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Data tester&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;L&amp;rsquo;adapter existant ne supporte pas le testnet.&lt;/p&gt;&#xA;&lt;p&gt;Créer une API key sur &lt;a href=&#34;https://testnet.binance.vision/key/register&#34;&gt;https://testnet.binance.vision/key/register&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;openssl genrsa -out test-prv-key.pem 2048&#xA;openssl rsa -in test-prv-key.pem -pubout -outform PEM -out test-pub-key.pem&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Je préconise de créer une autre example dans l&amp;rsquo;adapter binance: &lt;code&gt;node_data_tester_testnet.rs&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;export BINANCE_API_KEY=&amp;#34;API_KEY_FROM_BINANCE_TESTNET_WEBSITE&amp;#34;&#xA;export BINANCE_API_SECRET=&amp;#34;$(cat /path/to/test-prv-key.pem)&amp;#34;&#xA;cargo run --release --example binance-spot-data-tester-testnet --package nautilus-binance&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Résultat:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Premiers pas avec Nautilus trader</title>
      <link>https://leandeep.com/premiers-pas-avec-nautilus-trader/</link>
      <pubDate>Mon, 23 Feb 2026 21:19:00 +0000</pubDate>
      <guid>https://leandeep.com/premiers-pas-avec-nautilus-trader/</guid>
      <description>&lt;p&gt;Dans cet article, je parcours quelques adapters de Nautilus trader écrits en Rust pour récupérer les données en temps réel sur différents exchanges. Mon objectif est de réécrire des bots de trading en Rust et de voir si Nautilus trader pourrait m&amp;rsquo;aider à avancer plus vite que si je démarrais from scratch.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;accès-aux-données-dexchanges&#34;&gt;Accès aux données d&amp;rsquo;exchanges&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Binance&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Pour utilise l&amp;rsquo;adapter Binance, il faut générer une API key &lt;code&gt;Ed25519&lt;/code&gt;. On fournit à Binance un API secret et Binance fournit un API key.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Analyse du projet nautilus trader</title>
      <link>https://leandeep.com/analyse-du-projet-nautilus-trader/</link>
      <pubDate>Wed, 18 Feb 2026 21:19:00 +0000</pubDate>
      <guid>https://leandeep.com/analyse-du-projet-nautilus-trader/</guid>
      <description>&lt;p&gt;Dans cet article, nous allons voir ce qu&amp;rsquo;est Nautilus Trader et comment l&amp;rsquo;utiliser.&#xA;Je me suis penché sur cet outil car je m&amp;rsquo;étais fixé l&amp;rsquo;objectif de ré-écrire un bot de trading en Rust avant de m&amp;rsquo;apercevoir qu&amp;rsquo;il y avait déjà cette plateforme open source qui existait et qui contient déjà plus de 17 000 commits.&#xA;Plutôt que de réinventer la roue, l&amp;rsquo;idée est de voir si je peux m&amp;rsquo;approprier cet outil bot pour en faire un bot d&amp;rsquo;arbitage. Cela me permet aussi de me plonger dans un large projet Rust avec bindings pour Python. Et du coup s&amp;rsquo;il manque des features, ce sera avec grand plaisir que je pourrai les coder.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Video streaming app for VR headset using rust and webxr</title>
      <link>https://leandeep.com/video-streaming-app-for-vr-headset-using-rust-and-webxr/</link>
      <pubDate>Sun, 15 Feb 2026 21:19:00 +0000</pubDate>
      <guid>https://leandeep.com/video-streaming-app-for-vr-headset-using-rust-and-webxr/</guid>
      <description>&lt;p&gt;I have a lot of 360° videos recorded with a 360 camera, and I wanted to be able to stream them from my laptop. I’ve been wanting to experiment with VR app development for a long time, so I built an app using Rust as the backend server and WebXR for the UI.&lt;/p&gt;&#xA;&lt;p&gt;The learning curve between WebXR and Unity is much lower for a former frontend developer. I developed PWA apps for about 10 years, from 2009 to 2019, so it was pretty easy for me to pick it up. Having recently built the UI of a social network in React, transitioning to WebXR was seamless. Compared to Unity, the difference is night and day. I gave Unity a shot with no prior experience, and honestly, getting started was tough. Moreover I&amp;rsquo;m not a big fan of C#.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Install Nostr Rust relay without Docker</title>
      <link>https://leandeep.com/install-nostr-rust-relay-without-docker/</link>
      <pubDate>Sun, 04 May 2025 23:32:00 +0200</pubDate>
      <guid>https://leandeep.com/install-nostr-rust-relay-without-docker/</guid>
      <description>&lt;p&gt;In this article we are going to see how to setup a Nostr relay without Docker.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Prerequisites&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;rust installed (else &lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;&lt;strong&gt;Run Nostr relay without Docker&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get install build-essential cmake protobuf-compiler pkg-config libssl-dev&#xA;git clone -q https://git.sr.ht/\~gheartsfield/nostr-rs-relay&#xA;cd nostr-rs-relay&#xA;cargo build -q -r&#xA;&#xA;RUST_LOG=warn,nostr_rs_relay=info ./target/release/nostr-rs-relay&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And voila the relay will listen on port 8080.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Use an Oled display on ESP32 using Rust</title>
      <link>https://leandeep.com/use-an-oled-display-on-esp32-using-rust/</link>
      <pubDate>Thu, 17 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/use-an-oled-display-on-esp32-using-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to connect and display some content on an Oled display connected via I2C on an ESP-Wroom-32. The code is written in Rust.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;p&gt;Connect the Oled display to the ESP32 board:&lt;/p&gt;&#xA;&lt;p&gt;Voici le branchement I2C entre ton ESP32 et l’écran :&lt;/p&gt;&#xA;&lt;p&gt;It is an OLED (NFP1315-61AY)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Connect VCC to 3.3V&lt;/li&gt;&#xA;&lt;li&gt;Of course connect GND to GND&lt;/li&gt;&#xA;&lt;li&gt;Connect SCL to GPIO22&lt;/li&gt;&#xA;&lt;li&gt;Connect SDA to GPIO21&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;anyhow = &amp;#34;1.0&amp;#34;&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;&#xA;embedded-hal = &amp;#34;1.0.0&amp;#34;&#xA;embedded-graphics = &amp;#34;0.8.1&amp;#34;&#xA;ssd1306 = &amp;#34;0.10.0&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use anyhow::anyhow;&#xA;use esp_idf_hal::i2c::{I2cConfig, I2cDriver};&#xA;use esp_idf_hal::peripherals::Peripherals;&#xA;use esp_idf_hal::prelude::*;&#xA;use std::{thread, time::Duration}; // for .kHz()&#xA;&#xA;use embedded_graphics::{&#xA;    mono_font::{ascii::FONT_6X10, MonoTextStyle},&#xA;    pixelcolor::BinaryColor,&#xA;    prelude::*,&#xA;    text::Text,&#xA;};&#xA;&#xA;use ssd1306::{prelude::*, I2CDisplayInterface, Ssd1306};&#xA;&#xA;fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    let peripherals = Peripherals::take().unwrap();&#xA;    let i2c = peripherals.i2c0;&#xA;    let sda = peripherals.pins.gpio21;&#xA;    let scl = peripherals.pins.gpio22;&#xA;&#xA;    let config = I2cConfig::new().baudrate(400u32.kHz().into());&#xA;    let i2c_driver =&#xA;        I2cDriver::new(i2c, sda, scl, &amp;amp;config).map_err(|e| anyhow!(&amp;#34;I2C init error: {:?}&amp;#34;, e))?;&#xA;&#xA;    let interface = I2CDisplayInterface::new(i2c_driver);&#xA;    let mut display = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0)&#xA;        .into_buffered_graphics_mode();&#xA;&#xA;    display&#xA;        .init()&#xA;        .map_err(|e| anyhow!(&amp;#34;Display init error: {:?}&amp;#34;, e))?;&#xA;    display&#xA;        .flush()&#xA;        .map_err(|e| anyhow!(&amp;#34;Flush error: {:?}&amp;#34;, e))?;&#xA;&#xA;    let style = MonoTextStyle::new(&amp;amp;FONT_6X10, BinaryColor::On);&#xA;    Text::new(&amp;#34;Hello Olivier !!!&amp;#34;, Point::new(10, 32), style)&#xA;        .draw(&amp;amp;mut display)&#xA;        .map_err(|e| anyhow!(&amp;#34;Draw error: {:?}&amp;#34;, e))?;&#xA;&#xA;    display&#xA;        .flush()&#xA;        .map_err(|e| anyhow!(&amp;#34;Final flush error: {:?}&amp;#34;, e))?;&#xA;&#xA;    loop {&#xA;        thread::sleep(Duration::from_millis(1000));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;build&#34;&gt;Build&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# cargo generate --git https://github.com/esp-rs/esp-idf-template cargo&#xA;source ~/export-esp.sh&#xA;cargo build&#xA;espflash flash target/xtensa-esp32-espidf/debug/oled --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Read and write file in sdcard from ESP32 and Rust</title>
      <link>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</link>
      <pubDate>Sun, 13 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to read a file from a SD Card in Rust using the SPI port of the ESP32.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cargo install esp-generate@0.3.1&#xA;esp-generate --chip esp32 sd&#xA;source ~/export-esp.sh&#xA;cargo build&#xA;# espflash flash target/xtensa-esp32-none-elf/debug/sd --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;critical-section = &amp;#34;1.2.0&amp;#34;&#xA;embassy-executor = { version = &amp;#34;0.7.0&amp;#34;, features = [&amp;#34;task-arena-size-20480&amp;#34;] }&#xA;embassy-time     = { version = &amp;#34;0.4.0&amp;#34;, features = [&amp;#34;generic-queue-8&amp;#34;] }&#xA;esp-hal          = { version = &amp;#34;1.0.0-beta.0&amp;#34;, features = [&amp;#34;esp32&amp;#34;, &amp;#34;unstable&amp;#34;] }&#xA;esp-hal-embassy  = { version = &amp;#34;0.7.0&amp;#34;, features = [&amp;#34;esp32&amp;#34;] }&#xA;static_cell      = { version = &amp;#34;2.1.0&amp;#34;, features = [&amp;#34;nightly&amp;#34;] }&#xA;# sd card driver&#xA;embedded-sdmmc = &amp;#34;0.8.1&amp;#34;&#xA;# To convert Spi bus to SpiDevice&#xA;embedded-hal-bus = &amp;#34;0.3.0&amp;#34;&#xA;## For time parsing&#xA;chrono = { version = &amp;#34;0.4.40&amp;#34;, default-features = false }&#xA;esp-println = { version = &amp;#34;0.12.0&amp;#34;, features = [&amp;#34;esp32&amp;#34;, &amp;#34;log&amp;#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//cargo install esp-generate@0.3.1&#xA;//esp-generate --chip esp32 sd&#xA;//source ~/export-esp.sh&#xA;//cargo build&#xA;//espflash flash target/xtensa-esp32-none-elf/debug/sd --monitor&#xA;&#xA;#![no_std]&#xA;#![no_main]&#xA;&#xA;use embassy_executor::Spawner;&#xA;use embassy_time::{Delay, Duration, Timer};&#xA;use embedded_hal_bus::spi::ExclusiveDevice;&#xA;use embedded_sdmmc::{SdCard, TimeSource, Timestamp, VolumeIdx, VolumeManager};&#xA;use esp_hal::clock::CpuClock;&#xA;use esp_hal::gpio::{Level, Output, OutputConfig};&#xA;use esp_hal::spi;&#xA;use esp_hal::spi::master::Spi;&#xA;use esp_hal::time::Rate;&#xA;use esp_hal::timer::timg::TimerGroup;&#xA;use esp_println::{self as _, print, println};&#xA;&#xA;#[panic_handler]&#xA;fn panic(_: &amp;amp;core::panic::PanicInfo) -&amp;gt; ! {&#xA;    loop {}&#xA;}&#xA;&#xA;/// Code from https://github.com/rp-rs/rp-hal-boards/blob/main/boards/rp-pico/examples/pico_spi_sd_card.rs&#xA;/// A dummy timesource, which is mostly important for creating files.&#xA;#[derive(Default)]&#xA;pub struct DummyTimesource();&#xA;&#xA;impl TimeSource for DummyTimesource {&#xA;    // In theory you could use the RTC of the rp2040 here, if you had&#xA;    // any external time synchronizing device.&#xA;    fn get_timestamp(&amp;amp;self) -&amp;gt; Timestamp {&#xA;        Timestamp {&#xA;            year_since_1970: 0,&#xA;            zero_indexed_month: 0,&#xA;            zero_indexed_day: 0,&#xA;            hours: 0,&#xA;            minutes: 0,&#xA;            seconds: 0,&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;#[esp_hal_embassy::main]&#xA;async fn main(_spawner: Spawner) {&#xA;    let config = esp_hal::Config::default().with_cpu_clock(CpuClock::max());&#xA;    let peripherals = esp_hal::init(config);&#xA;&#xA;    let timer0 = TimerGroup::new(peripherals.TIMG1);&#xA;    esp_hal_embassy::init(timer0.timer0);&#xA;&#xA;    println!(&amp;#34;Embassy initialized!&amp;#34;);&#xA;&#xA;    let spi_bus = Spi::new(&#xA;        peripherals.SPI2,&#xA;        spi::master::Config::default()&#xA;            .with_frequency(Rate::from_khz(400))&#xA;            .with_mode(spi::Mode::_0),&#xA;    )&#xA;    .unwrap()&#xA;    .with_sck(peripherals.GPIO18)&#xA;    .with_mosi(peripherals.GPIO23)&#xA;    .with_miso(peripherals.GPIO19)&#xA;    .into_async();&#xA;    let sd_cs = Output::new(peripherals.GPIO5, Level::High, OutputConfig::default());&#xA;    let spi_dev = ExclusiveDevice::new(spi_bus, sd_cs, Delay).unwrap();&#xA;&#xA;    let sdcard = SdCard::new(spi_dev, Delay);&#xA;    let mut volume_mgr = VolumeManager::new(sdcard, DummyTimesource::default());&#xA;&#xA;    println!(&amp;#34;Init SD card controller and retrieve card size...&amp;#34;);&#xA;    let sd_size = volume_mgr.device().num_bytes().unwrap();&#xA;    println!(&amp;#34;SD card size is {} bytes\r\n&amp;#34;, sd_size);&#xA;&#xA;    let mut volume0 = volume_mgr.open_volume(VolumeIdx(0)).unwrap();&#xA;    let mut root_dir = volume0.open_root_dir().unwrap();&#xA;    {&#xA;        let mut my_file = root_dir&#xA;            .open_file_in_dir(&#xA;                &amp;#34;example.txt&amp;#34;,&#xA;                embedded_sdmmc::Mode::ReadWriteCreateOrTruncate,&#xA;            )&#xA;            .unwrap();&#xA;&#xA;        let line = &amp;#34;Hello Rust!&amp;#34;;&#xA;        if let Ok(()) = my_file.write(line.as_bytes()) {&#xA;            my_file.flush().unwrap();&#xA;            println!(&amp;#34;Written Data&amp;#34;);&#xA;        } else {&#xA;            println!(&amp;#34;Not written&amp;#34;);&#xA;        }&#xA;    }&#xA;    {&#xA;        let mut my_file = root_dir&#xA;            .open_file_in_dir(&amp;#34;example.txt&amp;#34;, embedded_sdmmc::Mode::ReadOnly)&#xA;            .unwrap();&#xA;&#xA;        while !my_file.is_eof() {&#xA;            let mut buffer = [0u8; 32];&#xA;&#xA;            if let Ok(n) = my_file.read(&amp;amp;mut buffer) {&#xA;                for b in &amp;amp;buffer[..n] {&#xA;                    print!(&amp;#34;{}&amp;#34;, *b as char);&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    loop {&#xA;        Timer::after(Duration::from_secs(30)).await;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Get ESP32 cores count and use multithreading in Rust</title>
      <link>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</link>
      <pubDate>Tue, 08 Apr 2025 22:49:00 +0200</pubDate>
      <guid>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</guid>
      <description>&lt;br/&gt;&#xA;&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;anyhow = &amp;#34;1.0&amp;#34;&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;count-cores-code&#34;&gt;Count cores code&lt;/h2&gt;&#xA;&lt;p&gt;Now update &lt;code&gt;main.rs&lt;/code&gt; and add this code:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use esp_idf_hal::cpu;&#xA;use esp_idf_svc::log::EspLogger;&#xA;&#xA;fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Starting program...&amp;#34;);&#xA;&#xA;    let cpu_cores = cpu::CORES;&#xA;    log::info!(&amp;#34;Cores count : {}&amp;#34;, cpu_cores);&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;build-and-run&#34;&gt;Build and Run&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cargo generate --git https://github.com/esp-rs/esp-idf-template cargo&#xA;cd core&#xA;source ~/export-esp.sh&#xA;cargo build&#xA;espflash flash target/xtensa-esp32-espidf/debug/core --monitor&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;execute-code-in-different-threads-code&#34;&gt;Execute code in different threads code&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use core::time::Duration;&#xA;use std::thread;&#xA;fn main() {&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Starting multi-threaded example on ESP32&amp;#34;);&#xA;&#xA;    // Spawn thread 1 on Core 0&#xA;    thread::spawn(|| {&#xA;        loop {&#xA;            log::info!(&amp;#34;Task running on Core 0&amp;#34;);&#xA;            thread::sleep(Duration::from_secs(2)); // Simulate work&#xA;        }&#xA;    });&#xA;&#xA;    // Spawn thread 2 on Core 1&#xA;    thread::spawn(|| {&#xA;        loop {&#xA;            log::info!(&amp;#34;Task running on Core 1&amp;#34;);&#xA;            thread::sleep(Duration::from_secs(4)); // Simulate work&#xA;        }&#xA;    });&#xA;&#xA;    // Keep the main thread alive&#xA;    loop {&#xA;        thread::sleep(Duration::from_secs(10));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;h2 id=&#34;execute-code-in-different-threads-and-share-variable&#34;&gt;Execute code in different threads and share variable&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use core::time::Duration;&#xA;use std::sync::{Arc, Mutex};&#xA;use std::thread;&#xA;&#xA;fn main() {&#xA;    // Initialisation du logger&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Starting program&amp;#34;);&#xA;&#xA;    // Shared variable between threads&#xA;    let shared_counter = Arc::new(Mutex::new(0));&#xA;&#xA;    // Spawn thread 1 on Core 0&#xA;    let counter_thread_1 = Arc::clone(&amp;amp;shared_counter);&#xA;    thread::spawn(move || {&#xA;        loop {&#xA;            {&#xA;                let mut counter = counter_thread_1.lock().unwrap();&#xA;                *counter += 1;&#xA;                log::info!(&amp;#34;Core 0 incremented counter to {}&amp;#34;, *counter);&#xA;            }&#xA;            thread::sleep(Duration::from_secs(2)); // Simule du travail&#xA;        }&#xA;    });&#xA;&#xA;    // Spawn thread 2 on Core 1&#xA;    let counter_thread_2 = Arc::clone(&amp;amp;shared_counter);&#xA;    thread::spawn(move || {&#xA;        loop {&#xA;            {&#xA;                let mut counter = counter_thread_2.lock().unwrap();&#xA;                *counter += 2;&#xA;                log::info!(&amp;#34;Core 1 incremented counter to {}&amp;#34;, *counter);&#xA;            }&#xA;            thread::sleep(Duration::from_secs(4)); // Simule du travail&#xA;        }&#xA;    });&#xA;&#xA;    // Main Thread: read shared variable value&#xA;    loop {&#xA;        {&#xA;            let counter = shared_counter.lock().unwrap();&#xA;            log::info!(&amp;#34;Main thread reads counter: {}&amp;#34;, *counter);&#xA;        }&#xA;        thread::sleep(Duration::from_secs(5));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Scan Wifi networks on ESP32 using Rust</title>
      <link>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</link>
      <pubDate>Tue, 08 Apr 2025 20:49:00 +0200</pubDate>
      <guid>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to scan Wifi networks around you.&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;p&gt;The crates used are the following ones:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[dependencies]&#xA;log = &amp;#34;0.4&amp;#34;&#xA;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use esp_idf_hal::prelude::*;&#xA;use esp_idf_svc::eventloop::EspSystemEventLoop;&#xA;use esp_idf_svc::nvs::EspDefaultNvsPartition;&#xA;use esp_idf_svc::sys::EspError;&#xA;use esp_idf_svc::wifi::{AuthMethod, BlockingWifi, ClientConfiguration, Configuration, EspWifi};&#xA;use std::thread;&#xA;use std::time::Duration;&#xA;&#xA;fn main() -&amp;gt; Result&amp;lt;(), EspError&amp;gt; {&#xA;    esp_idf_svc::sys::link_patches();&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::set_max_level(log::LevelFilter::Info);&#xA;    log::info!(&amp;#34;Program started!&amp;#34;);&#xA;&#xA;    // Init needed components&#xA;    let peripherals = Peripherals::take().unwrap();&#xA;    let nvs = EspDefaultNvsPartition::take()?;&#xA;    let sys_loop = EspSystemEventLoop::take()?;&#xA;&#xA;    // Init WiFi&#xA;    let esp_wifi = EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?;&#xA;    let mut wifi = BlockingWifi::wrap(esp_wifi, sys_loop)?;&#xA;&#xA;    let wifi_config = Configuration::Client(ClientConfiguration::default());&#xA;    wifi.set_configuration(&amp;amp;wifi_config)?;&#xA;&#xA;    wifi.start()?;&#xA;    println!(&amp;#34;WiFi started in station mode&amp;#34;);&#xA;    thread::sleep(Duration::from_secs(2));&#xA;&#xA;    // Boucle infinie pour scanner les réseaux&#xA;    loop {&#xA;        println!(&amp;#34;\n=== Scanning WiFi networks... ===&amp;#34;);&#xA;&#xA;        match wifi.scan() {&#xA;            Ok(scan_result) =&amp;gt; {&#xA;                println!(&amp;#34;{} WiFi networks detected:&amp;#34;, scan_result.len());&#xA;&#xA;                // Sort networks per signal power (stronger first)&#xA;                let mut networks = scan_result;&#xA;                networks.sort_by(|a, b| b.signal_strength.cmp(&amp;amp;a.signal_strength));&#xA;&#xA;                for (i, ap) in networks.iter().enumerate() {&#xA;                    // Convert SSID to String&#xA;                    let ssid = if ap.ssid.is_empty() {&#xA;                        &amp;#34;&amp;lt;Hidden network&amp;gt;&amp;#34;.to_string()&#xA;                    } else {&#xA;                        ap.ssid.to_string()&#xA;                    };&#xA;&#xA;                    // Format BSSID to MAC address&#xA;                    let mac = format!(&#xA;                        &amp;#34;{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}&amp;#34;,&#xA;                        ap.bssid[0],&#xA;                        ap.bssid[1],&#xA;                        ap.bssid[2],&#xA;                        ap.bssid[3],&#xA;                        ap.bssid[4],&#xA;                        ap.bssid[5]&#xA;                    );&#xA;&#xA;                    println!(&#xA;                        &amp;#34;{:2}. SSID: {:32} | Signal: {:4} dBm | Channel: {:2} | MAC: {:17} | Security: {:?}&amp;#34;,&#xA;                        i + 1,&#xA;                        ssid,&#xA;                        ap.signal_strength,&#xA;                        ap.channel,&#xA;                        mac,&#xA;                        auth_method_to_string(ap.auth_method)&#xA;                    );&#xA;                }&#xA;            }&#xA;            Err(e) =&amp;gt; {&#xA;                println!(&amp;#34;Error while scanning: {:?}&amp;#34;, e);&#xA;            }&#xA;        }&#xA;&#xA;        println!(&amp;#34;Wait 5 seconds before next scan...&amp;#34;);&#xA;        thread::sleep(Duration::from_secs(5));&#xA;    }&#xA;}&#xA;&#xA;fn auth_method_to_string(auth: Option&amp;lt;AuthMethod&amp;gt;) -&amp;gt; &amp;amp;&amp;#39;static str {&#xA;    match auth {&#xA;        Some(AuthMethod::None) =&amp;gt; &amp;#34;Open&amp;#34;,&#xA;        Some(AuthMethod::WEP) =&amp;gt; &amp;#34;WEP&amp;#34;,&#xA;        Some(AuthMethod::WPA) =&amp;gt; &amp;#34;WPA&amp;#34;,&#xA;        Some(AuthMethod::WPA2Personal) =&amp;gt; &amp;#34;WPA2-Personal&amp;#34;,&#xA;        Some(AuthMethod::WPA3Personal) =&amp;gt; &amp;#34;WPA3-Personal&amp;#34;,&#xA;        Some(AuthMethod::WPA2Enterprise) =&amp;gt; &amp;#34;WPA2-Enterprise&amp;#34;,&#xA;        Some(AuthMethod::WPA2WPA3Personal) =&amp;gt; &amp;#34;WPA2/WPA3&amp;#34;,&#xA;        None =&amp;gt; &amp;#34;Unknown&amp;#34;,&#xA;        _ =&amp;gt; &amp;#34;Unknown&amp;#34;,&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Get GPS coordinates on ESP32 using Rust</title>
      <link>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</link>
      <pubDate>Wed, 02 Apr 2025 20:49:00 +0200</pubDate>
      <guid>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</guid>
      <description>&lt;p&gt;In this article we are going to see how to retrieve NMEA sentences from a GPS module NEO-6M connected to an ESP32.&lt;/p&gt;&#xA;&lt;p&gt;&lt;br/&gt;&#xA;Connect the NEO-6M GPS module to the ESP32&#xA;&lt;br/&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/esp-gps.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;br/&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Dependencies:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] }&#xA;esp-idf-hal = &amp;#34;0.45.2&amp;#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&#xA;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;use esp_idf_hal::peripherals::Peripherals;&#xA;use esp_idf_hal::prelude::*;&#xA;use esp_idf_hal::uart::*;&#xA;use esp_idf_svc::hal::uart::config::DataBits;&#xA;use esp_idf_svc::hal::uart::config::StopBits;&#xA;&#xA;fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {&#xA;    // Lien des patches ESP-IDF&#xA;    esp_idf_svc::sys::link_patches();&#xA;    &#xA;    // Configuration du logger&#xA;    esp_idf_svc::log::EspLogger::initialize_default();&#xA;    log::info!(&amp;#34;Démarrage de l&amp;#39;application GPS&amp;#34;);&#xA;&#xA;    // Initialisation des périphériques&#xA;    let peripherals = Peripherals::take().unwrap();&#xA;    &#xA;    // Configuration de l&amp;#39;UART&#xA;    let config = config::Config::default()&#xA;        .baudrate(Hertz(9600))&#xA;        .data_bits(DataBits::DataBits8)&#xA;        .parity_none()&#xA;        .stop_bits(StopBits::STOP1);&#xA;&#xA;    // Création du driver UART avec typage explicite&#xA;    let mut uart_driver = UartDriver::new(&#xA;        peripherals.uart2,&#xA;        peripherals.pins.gpio17, // TX&#xA;        peripherals.pins.gpio16, // RX&#xA;        Option::&amp;lt;esp_idf_hal::gpio::Gpio0&amp;gt;::None, // RTS (pas utilisé)&#xA;        Option::&amp;lt;esp_idf_hal::gpio::Gpio0&amp;gt;::None, // CTS (pas utilisé)&#xA;        &amp;amp;config,&#xA;    )?;&#xA;&#xA;    println!(&amp;#34;UART initialisé avec un débit de 9600 bauds&amp;#34;);&#xA;&#xA;    // Buffer pour stocker les données GPS&#xA;    let mut buffer = [0u8; 128];&#xA;    &#xA;    loop {&#xA;        // Lecture des données disponibles sur l&amp;#39;UART avec timeout&#xA;        match uart_driver.read(&amp;amp;mut buffer, 1000) {&#xA;            Ok(bytes_read) if bytes_read &amp;gt; 0 =&amp;gt; {&#xA;                let gps_data = &amp;amp;buffer[..bytes_read];&#xA;                println!(&#xA;                    &amp;#34;Données GPS reçues : {}&amp;#34;,&#xA;                    String::from_utf8_lossy(gps_data)&#xA;                );&#xA;            },&#xA;            Ok(_) =&amp;gt; {&#xA;                println!(&amp;#34;Aucune donnée GPS reçue (timeout)&amp;#34;);&#xA;            },&#xA;            Err(e) =&amp;gt; {&#xA;                println!(&amp;#34;Erreur de lecture UART: {:?}&amp;#34;, e);&#xA;            }&#xA;        }&#xA;&#xA;        println!(&amp;#34;-------------------------------&amp;#34;);&#xA;        std::thread::sleep(std::time::Duration::from_secs(1));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
