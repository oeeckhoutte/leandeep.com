<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/rust/</link>
    <description>Recent content in Rust on Lean Deep Tech blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 13 Apr 2025 22:49:00 +0200</lastBuildDate><atom:link href="https://leandeep.com/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Read and write file in sdcard from ESP32 and Rust</title>
      <link>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</link>
      <pubDate>Sun, 13 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/read-and-write-file-in-sdcard-from-esp32-and-rust/</guid>
      <description>In this article we are going to see how to read a file from a SD Card in Rust using the SPI port of the ESP32.
Prerequisites cargo install esp-generate@0.3.1 esp-generate --chip esp32 sd source ~/export-esp.sh cargo build # espflash flash target/xtensa-esp32-none-elf/debug/sd --monitor Dependencies [dependencies] critical-section = &amp;#34;1.2.0&amp;#34; embassy-executor = { version = &amp;#34;0.7.0&amp;#34;, features = [&amp;#34;task-arena-size-20480&amp;#34;] } embassy-time = { version = &amp;#34;0.4.0&amp;#34;, features = [&amp;#34;generic-queue-8&amp;#34;] } esp-hal = { version = &amp;#34;1.</description>
    </item>
    
    <item>
      <title>Get ESP32 cores count and use multithreading in Rust</title>
      <link>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</link>
      <pubDate>Tue, 08 Apr 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/get-esp32-cores-count-and-use-multithreading-in-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1.0&amp;#34; esp-idf-hal = &amp;#34;0.45.2&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } Count cores code Now update main.rs and add this code:
use esp_idf_hal::cpu; use esp_idf_svc::log::EspLogger; fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; { EspLogger::initialize_default(); log::info!(&amp;#34;Starting program...&amp;#34;); let cpu_cores = cpu::CORES; log::info!(&amp;#34;Cores count : {}&amp;#34;, cpu_cores); Ok(()) } Build and Run cargo generate --git https://github.com/esp-rs/esp-idf-template cargo cd core source ~/export-esp.sh cargo build espflash flash target/xtensa-esp32-espidf/debug/core --monitor Execute code in different threads code use core::time::Duration; use std::thread; fn main() { esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
    <item>
      <title>Scan Wifi networks on ESP32 using Rust</title>
      <link>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</link>
      <pubDate>Tue, 08 Apr 2025 20:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/scan-wifi-networks-on-esp32-using-rust/</guid>
      <description>In this article we are going to see how to scan Wifi networks around you.
The crates used are the following ones:
[dependencies] log = &amp;#34;0.4&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; use esp_idf_hal::prelude::*; use esp_idf_svc::eventloop::EspSystemEventLoop; use esp_idf_svc::nvs::EspDefaultNvsPartition; use esp_idf_svc::sys::EspError; use esp_idf_svc::wifi::{AuthMethod, BlockingWifi, ClientConfiguration, Configuration, EspWifi}; use std::thread; use std::time::Duration; fn main() -&amp;gt; Result&amp;lt;(), EspError&amp;gt; { esp_idf_svc::sys::link_patches(); esp_idf_svc::log::EspLogger::initialize_default(); log::set_max_level(log::LevelFilter::Info); log::info!(&amp;#34;Program started!&amp;#34;); // Init needed components let peripherals = Peripherals::take().</description>
    </item>
    
    <item>
      <title>Get GPS coordinates on ESP32 using Rust</title>
      <link>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</link>
      <pubDate>Wed, 02 Apr 2025 20:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/get-gps-coordinates-on-esp32-using-rust/</guid>
      <description>In this article we are going to see how to retrieve NMEA sentences from a GPS module NEO-6M connected to an ESP32.
Connect the NEO-6M GPS module to the ESP32 Dependencies:
esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; use esp_idf_hal::peripherals::Peripherals; use esp_idf_hal::prelude::*; use esp_idf_hal::uart::*; use esp_idf_svc::hal::uart::config::DataBits; use esp_idf_svc::hal::uart::config::StopBits; fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; { // Lien des patches ESP-IDF esp_idf_svc::sys::link_patches(); // Configuration du logger esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
    <item>
      <title>Connect ESP32 to wifi network using Rust</title>
      <link>https://leandeep.com/connect-esp32-to-wifi-network-using-rust/</link>
      <pubDate>Fri, 28 Mar 2025 15:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/connect-esp32-to-wifi-network-using-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1&amp;#34; embedded-svc = { version = &amp;#34;0.28&amp;#34;, default-features = false } esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } Code Now update main.rs and add this code:
use core::convert::TryInto; use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration}; use esp_idf_svc::hal::prelude::Peripherals; use esp_idf_svc::log::EspLogger; use esp_idf_svc::wifi::{BlockingWifi, EspWifi}; use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition}; use log::info; const SSID: &amp;amp;str = &amp;#34;SSID&amp;#34;; const PASSWORD: &amp;amp;str = &amp;#34;password&amp;#34;; fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; { esp_idf_svc::sys::link_patches(); EspLogger::initialize_default(); let peripherals = Peripherals::take()?</description>
    </item>
    
    <item>
      <title>Power on a PC when a button is pushed on an ESP32 using Rust</title>
      <link>https://leandeep.com/power-on-a-pc-when-a-button-is-pushed-on-an-esp32-using-rust/</link>
      <pubDate>Fri, 28 Mar 2025 15:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/power-on-a-pc-when-a-button-is-pushed-on-an-esp32-using-rust/</guid>
      <description>Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; anyhow = &amp;#34;1&amp;#34; embedded-svc = { version = &amp;#34;0.28&amp;#34;, default-features = false } esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; Code Now update main.rs and add this code:
use core::convert::TryInto; use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration}; //use esp_idf_svc::hal::prelude::Peripherals; use esp_idf_svc::log::EspLogger; use esp_idf_svc::wifi::{BlockingWifi, EspWifi}; use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition}; use log::info; use std::net::{UdpSocket, Ipv4Addr, SocketAddrV4}; use std::time::Duration; use esp_idf_hal::delay::FreeRtos; use esp_idf_hal::gpio::PinDriver; use esp_idf_hal::peripherals::Peripherals; const SSID: &amp;amp;str = &amp;#34;.</description>
    </item>
    
    <item>
      <title>Switch on a LED using Rust when a button is pushed on ESP32</title>
      <link>https://leandeep.com/switch-on-a-led-using-rust-when-a-button-is-pushed-on-esp32/</link>
      <pubDate>Fri, 28 Mar 2025 14:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/switch-on-a-led-using-rust-when-a-button-is-pushed-on-esp32/</guid>
      <description>The idea of this article is to explore how to switch on a LED when a push button is pressed. Once it is release the LED is switched off.
Prerequisites [dependencies] log = &amp;#34;0.4&amp;#34; esp-idf-svc = { version = &amp;#34;0.51&amp;#34;, features = [&amp;#34;critical-section&amp;#34;, &amp;#34;embassy-time-driver&amp;#34;, &amp;#34;embassy-sync&amp;#34;] } esp-idf-hal = &amp;#34;0.45.2&amp;#34; Code Now update main.rs and add this code:
use esp_idf_hal::delay::FreeRtos; use esp_idf_hal::gpio::PinDriver; use esp_idf_hal::peripherals::Peripherals; fn main() -&amp;gt; ! { esp_idf_svc::sys::link_patches(); // Bind the log crate to the ESP Logging facilities esp_idf_svc::log::EspLogger::initialize_default(); log::info!</description>
    </item>
    
    <item>
      <title>Make onboard LED blink using Rust on ESP32</title>
      <link>https://leandeep.com/make-onboard-led-blink-using-rust-on-esp32/</link>
      <pubDate>Fri, 28 Mar 2025 11:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/make-onboard-led-blink-using-rust-on-esp32/</guid>
      <description>AI tools are awesome. Lately, I&amp;rsquo;ve been wondering if they could replace us developers, but actually no it&amp;rsquo;s impossible because you always have issues. However, it&amp;rsquo;s crazy how much they boost my productivity. I now do my research directly on LLMs and get answers much faster than if I had searched on Google myself. It&amp;rsquo;s fantastic!
In this new article, we will explore how to make an onboard LED blink on an ESP32 using Rust.</description>
    </item>
    
    <item>
      <title>Run Rust code on ESP32</title>
      <link>https://leandeep.com/run-rust-code-on-esp32/</link>
      <pubDate>Mon, 24 Mar 2025 22:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/run-rust-code-on-esp32/</guid>
      <description>In this brief article, we will explore how to set up the ESP32 development environment to build and run Rust code on the ESP-WROOM-32. This procedure is written to work on Ubuntu 22 with a 64-bit Intel processor. The ESP32 is connected to the PC via USB.
Installation Install Ubuntu packages
sudo apt install -y build-essential libssl-dev pkg-config git sudo apt install -y python3-pip python3-venv Configure USB permissions
sudo usermod -aG dialout $USER sudo usermod -aG tty $USER # Restart the session Install Rust</description>
    </item>
    
    <item>
      <title>Rust pour développeurs Python</title>
      <link>https://leandeep.com/rust-pour-d%C3%A9veloppeurs-python/</link>
      <pubDate>Sun, 23 Oct 2022 07:49:00 +0200</pubDate>
      
      <guid>https://leandeep.com/rust-pour-d%C3%A9veloppeurs-python/</guid>
      <description>Petit guide rapide pour les Pythonistas souhaitant devenir Rustaceans.
Python 1. Conventions et guidelines PEP8 2. Tooling requirements.txt setup.py PyPI pip setuptools &amp; poetry pour distribuer des libs pipenv pour la gestion des dépendances twine pour uploader un package venv pour isoler un env pyenv pour gérer ≠ versions de Python pydoc &amp; Sphinx pour générer la doc Python pour interpréter/ compiler ipython comme REPL ipdb pour debugguer 3. Librairies et frameworks urllib requests json pyYAML csv datetime &amp; dateutils click &amp; argparse docopt re subprocess multiprocessing logging pathlib pickle heapq flask cryptography pymongo jinja2 pyside pytest Flake8 Black itertools celery boto 4.</description>
    </item>
    
  </channel>
</rss>
