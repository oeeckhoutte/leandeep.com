<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backtesting on Lean Deep Tech blog</title>
    <link>https://leandeep.com/tags/backtesting/</link>
    <description>Recent content in Backtesting on Lean Deep Tech blog</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Fri, 02 Feb 2024 18:10:00 +0000</lastBuildDate>
    <atom:link href="https://leandeep.com/tags/backtesting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Backtester ses stratégies de trading avec Backtrader</title>
      <link>https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/</link>
      <pubDate>Fri, 02 Feb 2024 18:10:00 +0000</pubDate>
      <guid>https://leandeep.com/backtester-ses-strat%C3%A9gies-de-trading-avec-backtrader/</guid>
      <description>&lt;p&gt;Voici un exemple de code Python permettant de backtester une stratégie (ici j&amp;rsquo;en ai créé une complètement inutile mais cela permet d&amp;rsquo;illustrer mon propose).&lt;/p&gt;&#xA;&lt;p&gt;&lt;br/&gt;&#xA;&lt;strong&gt;Pré-requis&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip install Pyarrow==15.0.0 pandas==2.2.0 backtrader==1.9.78.123 matplotlib==3.8.2&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;br/&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import math&#xA;import pandas as pd&#xA;import backtrader as bt&#xA;import ccxt&#xA;&#xA;# Charger les données historiques depuis Binance&#xA;exchange = ccxt.binance(&#xA;    {&#xA;        &amp;#34;apiKey&amp;#34;: &amp;#34;&amp;#34;,&#xA;        &amp;#34;secret&amp;#34;: &amp;#34;&amp;#34;,&#xA;    }&#xA;)&#xA;&#xA;symbol = &amp;#34;ETH/USDT&amp;#34;&#xA;timeframe = &amp;#34;1h&amp;#34;&#xA;&#xA;ohlcv = exchange.fetch_ohlcv(symbol, timeframe)&#xA;df = pd.DataFrame(&#xA;    ohlcv, columns=[&amp;#34;timestamp&amp;#34;, &amp;#34;open&amp;#34;, &amp;#34;high&amp;#34;, &amp;#34;low&amp;#34;, &amp;#34;close&amp;#34;, &amp;#34;volume&amp;#34;]&#xA;)&#xA;df[&amp;#34;timestamp&amp;#34;] = pd.to_datetime(df[&amp;#34;timestamp&amp;#34;], unit=&amp;#34;ms&amp;#34;)&#xA;df.set_index(&amp;#34;timestamp&amp;#34;, inplace=True)&#xA;&#xA;&#xA;# Définir la stratégie&#xA;class MovingAverageCrossStrategy(bt.Strategy):&#xA;    params = (&#xA;        (&amp;#34;short_period&amp;#34;, 20),&#xA;        (&amp;#34;long_period&amp;#34;, 50),&#xA;    )&#xA;&#xA;    def __init__(self):&#xA;        self.short_ma = bt.indicators.SimpleMovingAverage(&#xA;            self.data.close, period=self.params.short_period&#xA;        )&#xA;        self.long_ma = bt.indicators.SimpleMovingAverage(&#xA;            self.data.close, period=self.params.long_period&#xA;        )&#xA;        self.crossover = bt.indicators.CrossOver(self.short_ma, self.long_ma)&#xA;&#xA;    def next(self):&#xA;        if self.crossover &amp;gt; 0:&#xA;            # Signal d&amp;#39;achat&#xA;            self.buy()&#xA;        elif self.crossover &amp;lt; 0:&#xA;            # Signal de vente&#xA;            self.sell()&#xA;&#xA;&#xA;# Convertir les données pandas en format compréhensible par backtrader&#xA;data = bt.feeds.PandasData(dataname=df)&#xA;&#xA;# Configurer le cerveau du backtest&#xA;cerebro = bt.Cerebro()&#xA;cerebro.adddata(data)&#xA;cerebro.addstrategy(MovingAverageCrossStrategy)&#xA;&#xA;# Ajouter un observer pour afficher les gains/pertes&#xA;cerebro.addobserver(bt.observers.Value)&#xA;&#xA;# Paramètres du backtest&#xA;start_date = pd.to_datetime(&amp;#34;2022-01-01&amp;#34;)&#xA;end_date = pd.to_datetime(&amp;#34;2022-12-31&amp;#34;)&#xA;cerebro.run(stdstats=False, tradehistory=True, fromdate=start_date, todate=end_date)&#xA;&#xA;# Afficher les gains/pertes&#xA;final_portfolio_value = cerebro.broker.getvalue()&#xA;print(f&amp;#34;Capital final: {final_portfolio_value} USDT&amp;#34;)&#xA;cerebro.plot()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://leandeep.com/images/backtrader.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Créer un dataset avec les données Binance OHLCV pour réaliser des backtests</title>
      <link>https://leandeep.com/cr%C3%A9er-un-dataset-avec-les-donn%C3%A9es-binance-ohlcv-pour-r%C3%A9aliser-des-backtests/</link>
      <pubDate>Fri, 27 Jan 2023 10:49:00 +0200</pubDate>
      <guid>https://leandeep.com/cr%C3%A9er-un-dataset-avec-les-donn%C3%A9es-binance-ohlcv-pour-r%C3%A9aliser-des-backtests/</guid>
      <description>&lt;p&gt;Sans utiliser la librairie CCTX dont j&amp;rsquo;ai parlé &lt;a href=&#34;https://leandeep.com/retourner-un-dataframe-ohlcv-des-tickers-binance-%C3%A0-partir-de-cctx/&#34;&gt;dans l&amp;rsquo;article&lt;/a&gt;, voici comment récupérer directement les données OHLCV depuis l&amp;rsquo;API de Binance:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import requests&#xA;import datetime&#xA;import pandas as pd&#xA;import numpy as np&#xA;&#xA;start_date = &amp;#34;2022-01-01&amp;#34;&#xA;end_date = &amp;#34;2022-01-31&amp;#34;&#xA;interval = &amp;#34;1m&amp;#34;&#xA;symbol = &amp;#34;BTCUSDT&amp;#34;&#xA;&#xA;&#xA;def get_binance_data(&#xA;    ticker: str,&#xA;    interval: str = &amp;#34;4h&amp;#34;,&#xA;    limit: int = 500,&#xA;    start: str = &amp;#34;2018-01-01 00:00:00&amp;#34;,&#xA;) -&amp;gt; pd.DataFrame:&#xA;    &amp;#34;&amp;#34;&amp;#34;Get X (limit) OHLCV entries from Binance&amp;#34;&amp;#34;&amp;#34;&#xA;    columns = [&#xA;        &amp;#34;open_time&amp;#34;,&#xA;        &amp;#34;open&amp;#34;,&#xA;        &amp;#34;high&amp;#34;,&#xA;        &amp;#34;low&amp;#34;,&#xA;        &amp;#34;close&amp;#34;,&#xA;        &amp;#34;volume&amp;#34;,&#xA;        &amp;#34;close_time&amp;#34;,&#xA;        &amp;#34;qav&amp;#34;,&#xA;        &amp;#34;num_trades&amp;#34;,&#xA;        &amp;#34;taker_base_vol&amp;#34;,&#xA;        &amp;#34;taker_quote_vol&amp;#34;,&#xA;        &amp;#34;ignore&amp;#34;,&#xA;    ]&#xA;    start = int(datetime.datetime.timestamp(pd.to_datetime(start)) * 1000)&#xA;    base_url = &amp;#34;https://www.binance.com/api/v3/klines&amp;#34;&#xA;    query_params = (&#xA;        f&amp;#34;?symbol={ticker}&amp;amp;interval={interval}&amp;amp;limit={limit}&amp;amp;startTime={start}&amp;#34;&#xA;    )&#xA;    url = base_url + query_params&#xA;    data = pd.DataFrame(&#xA;        requests.get(url).json(), columns=columns, dtype=np.float&#xA;    )&#xA;    data.index = [&#xA;        pd.to_datetime(x, unit=&amp;#34;ms&amp;#34;).strftime(&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;)&#xA;        for x in data.open_time&#xA;    ]&#xA;    use_cols = [&#xA;        &amp;#34;open&amp;#34;,&#xA;        &amp;#34;high&amp;#34;,&#xA;        &amp;#34;low&amp;#34;,&#xA;        &amp;#34;close&amp;#34;,&#xA;        &amp;#34;volume&amp;#34;,&#xA;        &amp;#34;qav&amp;#34;,&#xA;        &amp;#34;num_trades&amp;#34;,&#xA;        &amp;#34;taker_base_vol&amp;#34;,&#xA;        &amp;#34;taker_quote_vol&amp;#34;,&#xA;    ]&#xA;    data = data[use_cols]&#xA;    return data&#xA;&#xA;&#xA;if __name__ == &amp;#34;__main__&amp;#34;:&#xA;    df = get_binance_data(&amp;#34;BTCUSDT&amp;#34;, &amp;#34;1m&amp;#34;)&#xA;    print(df.head())&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&#xA;Résultat:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
