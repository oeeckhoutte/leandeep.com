<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author"
  content="Olivier Eeckhoutte">
<meta name="description"
  content="Pour bien comprendre comment fonctionnent les r√©seaux de neurones, nous allons en cr√©er un from scratch en JavaScript. Je pense que c&amp;rsquo;est int√©ressant d&amp;rsquo;en cr√©er un de toute pi√®ce avant de s&amp;rsquo;attaquer √† des r√©seaux de neurones profonds ou d&amp;rsquo;utiliser des frameworks qui masquent toute la complexit√©.
Introduction Un neurone biologique est compos√© d&amp;rsquo;un corps cellulaire, d&amp;rsquo;un r√©seau de dendrites et d&amp;rsquo;un axone.
Le corps cellulaire contient le patrimoine g√©n√©tique. Les signaux √©lectriques transitent par le r√©seau de dendrites." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<script>
  
  
  if (!(window.location.host.startsWith("127.0.0.1")) && !(window.location.host.startsWith("localhost"))) {
    if (window.location.protocol != "https:") {
      console.log("Redirecting to https...")
      window.location.protocol = "https";
    }
  }
</script>


<link rel="canonical" href="https://leandeep.com/programmer-un-r%C3%A9seau-de-neurones-en-javascript/" />




<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">



<script src="https://fb.me/react-15.1.0.min.js"></script>
<script src="https://fb.me/react-dom-15.1.0.min.js"></script>
<style>
  .nav-search {
    display: none;
    -webkit-flex-grow: 1;
    -ms-flex-positive: 1;
    position: relative;
    width: 90%;
    height: 47px;
    margin-top: 20px;
    background-color: white;
    z-index: 1000;
  }

  .nav-search.active {
    box-shadow: 0 4px 4px rgba(79, 79, 79, 0.21);
  }

  .nav-search.active .search-dropdown {
    display: block;
  }

  .nav-search.active .search-input {
    -webkit-animation: expand-search-box-animation 0.5s forwards;
    animation: expand-search-box-animation 0.5s forwards;
  }

  .nav-search.active .search-input input {
    border-width: 2px;
  }

  .nav-search.active .search-input .close-search {
    display: inline-block;
  }

  .nav-search.active .search-input .search-dropdown {
    display: block;
  }

  .nav-search .search-input {
    transition: left 0.2s ease-in-out;
    transition: width 0s ease-in-out;
  }

  .nav-search .search-input .search-icon {
    position: absolute;
    left: 15px;
    top: 13px;
    z-index: 999;
    color: black;
  }

  .nav-search .search-input input {
    font: 16px/1.875 "Avenir Next W01", "Avenir Next", "Helvetica Neue", Helvetica, sans-serif;
    height: 50px;
    border: 1px solid #1b98f4;
    border-radius: 4px;
    min-width: 200px;
    width: 100%;
    padding-left: 50px;
    background-color: white;
  }

  .nav-search .search-input input:focus {
    outline: none;
  }

  .nav-search .search-input i.close-search {
    color: #1b98f4;
    display: none;
    position: absolute;
    right: 15px;
    top: 13px;
    cursor: pointer;
  }

  .search-dropdown {
    box-sizing: border-box;
    color: #B3B3B3;
    font: 14px/1.875 "Avenir Next W01", "Avenir Next", "Helvetica Neue", Helvetica, sans-serif;
    opacity: 1.00;
    padding: 20px;
    width: 100%;
    -webkit-animation: expand-search-dropdown-animation 0.5s forwards;
    animation: expand-search-dropdown-animation 0.5s forwards;
    overflow-y: scroll;
    max-height: 400px;
    border-radius: 0 0 4px 4px;
    background-color: #FCFCFC;
    border: 1px solid #E0E0E0;
    box-shadow: 1px 3px 4px rgba(0, 0, 0, 0.09);
    display: none;
    background-color: white;
  }

  .search-dropdown .small {
    -webkit-flex-basis: 35%;
    -ms-flex-preferred-size: 35%;
    flex-basis: 35%;
  }

  .search-dropdown .search-section .hits-blank {
    color: #666;
    text-align: center;
    padding-top: 20px;
  }

  .search-dropdown a {
    text-decoration: none;
    color: inherit;
    z-index: 2000;
  }

  .hit {
    border-bottom: 1px solid #E6E6E6;
    margin-bottom: 20px;
  }

  .hit .hit-title {
    color: #1b98f4;
    font-family: 'bt_mono', monospace;
    font-weight: 500;
    margin-bottom: 0;
    margin-top: 0;
    display: inline-block;
    font-size: 14px;
  }

  .hit .hit-description {
    text-decoration: none;
    color: black;
    font-size: 14px;
    display: block;
    margin-top: 3px;
  }

  .hit .hit-anchor {
    font-size: 13px;
    color: #666;
  }

  .hit .algolia-docsearch-suggestion--highlight {
    background-color: #FFE9A4;
  }

  .hit:last-child {
     
  }

  .ais-hits--item:last-child .hit {
    border: 0;
  }
</style>

<style>
  #app {
    display: none;
     
    border-radius: 10px;
    box-shadow: 2px 5px 12px -1px rgba(0, 0, 0, 0.56);
    padding: 20px;
    background-color: white;
    max-width: 500px;
    margin: 15px auto;
    text-align: center;
    min-height: 500px;
  }

  #app input {
    margin: 0 auto;
    float: none;
    width: 100%;
    max-width: 300px;
    padding: 5px 10px;
    border: 2px solid black;
  }

  #app ul {
    margin: 0;
    padding: 0;
  }

  #app li {
    text-align: left;
    padding: 5px 10px;
    width: 100%;
    max-width: 280px;
    margin: 1px auto;
    background-color: white;
    border: 1px solid black;
    list-style: none;
  }
</style>




<title>
  
  Programmer un r√©seau de neurones en JavaScript :: Lean Deep Tech blog 
  
</title>



<link href="//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
  type="text/css">



<link rel="stylesheet" href="https://leandeep.com/main.min.75f4fccf704dff01fea880bd845a14a4f05d9c04ee40d8b8563f1a6ab98fe848.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://leandeep.com/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://leandeep.com/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://leandeep.com/favicon-16x16.png">
    <link rel="manifest" href="https://leandeep.com/site.webmanifest">
    <link rel="mask-icon" href="https://leandeep.com/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://leandeep.com/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="Programmer un r√©seau de neurones en JavaScript">
<meta itemprop="description" content="Pour bien comprendre comment fonctionnent les r√©seaux de neurones, nous allons en cr√©er un from scratch en JavaScript. Je pense que c&rsquo;est int√©ressant d&rsquo;en cr√©er un de toute pi√®ce avant de s&rsquo;attaquer √† des r√©seaux de neurones profonds ou d&rsquo;utiliser des frameworks qui masquent toute la complexit√©.
Introduction Un neurone biologique est compos√© d&rsquo;un corps cellulaire, d&rsquo;un r√©seau de dendrites et d&rsquo;un axone.
Le corps cellulaire contient le patrimoine g√©n√©tique. Les signaux √©lectriques transitent par le r√©seau de dendrites."><meta itemprop="datePublished" content="2017-06-03T22:45:00+00:00" />
<meta itemprop="dateModified" content="2017-06-03T22:45:00+00:00" />
<meta itemprop="wordCount" content="2141"><meta itemprop="image" content="https://leandeep.com"/>
<meta itemprop="keywords" content="Machine Learning,Javascript," /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://leandeep.com"/>

<meta name="twitter:title" content="Programmer un r√©seau de neurones en JavaScript"/>
<meta name="twitter:description" content="Pour bien comprendre comment fonctionnent les r√©seaux de neurones, nous allons en cr√©er un from scratch en JavaScript. Je pense que c&rsquo;est int√©ressant d&rsquo;en cr√©er un de toute pi√®ce avant de s&rsquo;attaquer √† des r√©seaux de neurones profonds ou d&rsquo;utiliser des frameworks qui masquent toute la complexit√©.
Introduction Un neurone biologique est compos√© d&rsquo;un corps cellulaire, d&rsquo;un r√©seau de dendrites et d&rsquo;un axone.
Le corps cellulaire contient le patrimoine g√©n√©tique. Les signaux √©lectriques transitent par le r√©seau de dendrites."/>





<meta property="article:published_time" content="2017-06-03 22:45:00 &#43;0000 UTC" />







    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://leandeep.com/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">$ cd /home/leandeep</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://leandeep.com/events/">Featured Articles</a></li><li><a href="https://leandeep.com/posts/">All Articles</a></li><li><a href="https://leandeep.com/about/">About</a></li><li><a href="https://leandeep.com/finance/">Finance</a></li><li><a href="https://leandeep.com/notebooks/">ML Notebooks</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>

            <div class="content">
                
    <main class="post">

        <div class="post-info">
            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>11 minutes

            

            </p>
        </div>

        <article>
            <h1 class="post-title">
                <a href="https://leandeep.com/programmer-un-r%C3%A9seau-de-neurones-en-javascript/">Programmer un r√©seau de neurones en JavaScript</a>
            </h1>

            

            <div class="post-content">
                <p>Pour bien comprendre comment fonctionnent les r√©seaux de neurones, nous allons en cr√©er un <em>from scratch</em> en JavaScript. Je pense que c&rsquo;est int√©ressant d&rsquo;en cr√©er un de toute pi√®ce avant de s&rsquo;attaquer √† des r√©seaux de neurones profonds ou d&rsquo;utiliser des frameworks qui masquent toute la complexit√©.</p>
<br/>
<h1 id="introduction">Introduction</h1>
<p>Un neurone biologique est compos√© d&rsquo;un corps cellulaire, d&rsquo;un r√©seau de dendrites et d&rsquo;un axone.</p>
<ul>
<li>Le corps cellulaire contient le patrimoine g√©n√©tique.</li>
<li>Les signaux √©lectriques transitent par le r√©seau de dendrites. Ces derni√®res correspondent aux entr√©es du neurone.</li>
<li>L&rsquo;axone √† la sortie du neurone permet de v√©hiculer l&rsquo;influx nerveux.</li>
</ul>
<p>Les neurones artificiels s&rsquo;inspirent du comportement des neurones biologiques; c&rsquo;est-√†-dire de leur capacit√© √† s&rsquo;activer √† partir d&rsquo;un seuil.</p>
<p><img src="https://leandeep.com/images/neurone-biologique-neurone-artificiel.jpg" alt="image"></p>
<p>Si on entre plus dans le d√©tail, un neurone calcule la somme pond√©r√©e de ses entr√©es, puis il compare le r√©sultat √† un seuil (dit seuil d&rsquo;activation). Basiquement, si la somme est sup√©rieure au seuil, alors il s&rsquo;active et sort la valeur 1. R√©ciproquement, si la somme est inf√©rieure au seuil, alors il ne s&rsquo;active pas et sort la valeur 0.</p>
<p>En ce qui concerne la somme pond√©r√©e, chaque entr√©e valant 0 ou 1 est multipli√©e par un coefficient qui repr√©sente son poids (on parle de poids synaptique).
A noter, que si un signal d&rsquo;entr√©e est √† 1, alors la valeur ce ce signal prend tout simplement la valeur du coefficient. De m√™me, si le signal d&rsquo;entr√©e est √† 0, alors sa valeur reste √† 0.</p>
<p>Un neurone fonctionne ainsi: il faut additionner toutes les valeurs obtenues par les sommes pond√©r√©es en entr√©e et comparer le r√©sultat √† la valeur d&rsquo;un seuil.</p>
<br/>
<h1 id="pr√©cision-sur-les-seuils-dactivation">Pr√©cision sur les seuils d&rsquo;activation</h1>
<p>Nous venons de voir dans le paragraphe pr√©c√©dent que la sortie d&rsquo;un neurone nous donnait 1 ou 0 en fonction du seuil d&rsquo;activation. C&rsquo;est tout √† fait vrai lorsqu&rsquo;on utilise une fonction √† seuil binaire. Mais en pratique on utilise d&rsquo;autres fonctions d&rsquo;activation nous donnant des valeurs num√©riques comprises entre 0 et 1. La plus r√©pandue est la &ldquo;fonction sigmo√Øde&rdquo; (aussi appel√©e &ldquo;fonction logistique&rdquo; ou &ldquo;courbe en S&rdquo;).</p>
<p>Avec cette fonction, le passage de 0 √† 1 est plus progressif comme on peut le voir sur la courbe suivante:</p>
<p><img src="https://leandeep.com/images/sigmoide.png" alt="image"></p>
<p>L&rsquo;√©quation de la fonction sigmo√Øde est la suivante:</p>
<p><img src="https://leandeep.com/images/equation-sigmoide.png" alt="image"></p>
<br/>
<h1 id="initialisation-de-notre-r√©seau-de-neurones">Initialisation de notre r√©seau de neurones</h1>
<p>Nous allons cr√©er un r√©seau simple permettant de r√©soudre un probl√®me simple.
Nous allons classifier en 4 cat√©gories des images noir et blanc r√©duites √† seulement 4 pixels. C&rsquo;est un exemple p√©dagagique bien s√ªr.</p>
<p>Pendant la phase d&rsquo;apprentissage, nous allons pr√©senter au r√©seau les images que l&rsquo;on souhaite reconna√Ætre. Puis pendant la phase de reconnaissance, on pr√©sente des images al√©atoires afin de v√©rifier si le r√©seau a bien appris.</p>
<p>Voici les images dont on va se servir pour entra√Æner notre r√©seau.</p>
<p><img src="https://leandeep.com/images/combinaison-images-apprentissage.png" alt="image"></p>
<p>Pour se simplifier la vie, nous allons repr√©senter ces images sous forme de tableau.</p>
<p><img src="https://leandeep.com/images/image-to-tableau.png" alt="image"></p>
<p>Nous allons les repr√©senter les 4 cat√©gories d&rsquo;images via un tableau √† 2 valeurs.</p>
<ul>
<li>[0, 0] pour les images n&rsquo;ayant aucun ou tous les pixels noirs</li>
<li>[0, 1] pour les images comprenant 1 pixel noir</li>
<li>[1, 0] pour les images comprenant 2 pixels noirs</li>
<li>[1, 1] pour les images comprenant 3 pixels noirs</li>
</ul>
<p>Nous allons construire un r√©seau comprenant 3 couches:</p>
<ul>
<li>La premi√®re couche (couche d&rsquo;entr√©e) contient 4 neurones en entr√©e pour les 4 pixels de l&rsquo;image.</li>
<li>La deuxi√®me couche est une couche cach√©e. Elle permet de faire la liaison entre la couche d&rsquo;entr√©e et la couche de sortie.</li>
<li>La 3√®me couche (couche de sortie) contient 2 neurones pour les 2 valeurs repr√©sentant notre cat√©gorie.</li>
</ul>
<p><img src="https://leandeep.com/images/Reseau-de-neurones-simple.png" alt="image"></p>
<p>Pour construire un r√©seau de neurones avec une structure simple comme celle-ci, il suffit d&rsquo;assembler les neurones les uns derri√®res les autres. On connecte les sorties des uns aux entr√©es des autres.
Entre chaque couche, nous relions les sorties des neurones de la couche pr√©c√©dente √† tous les neurones de la couche suivante.
Dans notre exemple simple, on appelle ce genre de r√©seau un r√©seau totalement connect√©.</p>
<p>En JavaScript, on initialise les couches du r√©seau via des tableaux:</p>
<pre tabindex="0"><code>let input = [];
let hidden = [];
let output = [];
</code></pre><p>En plus de ces tableaux, il nous en faut 2 autres pour stocker les valeurs des poids synaptiques associ√©s aux connexions entre la 1√®re et 2√®me couches et la 2√®me et 3√®me couches:</p>
<pre tabindex="0"><code>let Wh = [];
let Wo = [];
</code></pre><p>On va cr√©er un dernier tableau pour notre input:</p>
<pre tabindex="0"><code>// Tableau repr√©sentant notre image en input
let inputData = [0, 1, 0, 1]
</code></pre><p>On cr√©e une fonction d&rsquo;initialisation des diff√©rents tableaux.</p>
<pre tabindex="0"><code>const reset = () =&gt; {
    input = [0, 0, 0, 0];
    hidden = [0, 0, 0, 0];
    output = [0, 0];
    
    // 0.5 a √©t√© choisi totalement arbitrairement
    // En pratique, on aurait pu g√©n√©rer des valeurs al√©atoires distribu√©es uniform√©ment sur l&#39;intervalle [-1; 1] et dont la moyenne aurait √©t√© nulle.
    Wh = [[0.5, 0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5, 0.5], 
         [0.5, 0.5, 0.5, 0.5]
         [0.5, 0.5, 0.5, 0.5]];
         
    Wo = [[0.5, 0.5, 0.5, 0.5],
         [0.5, 0.5, 0.5, 0.5]];
}
</code></pre><p>Chaque neurone de la couche d&rsquo;entr√©e est connect√© √† tous les neurones de la couche cach√©e. Par cons√©quent, il y aura 4 poids synaptiques √† prendre en compte dans le calcul de la moyenne pond√©r√©e pour chaque neurone de la couche cach√©e. Wh contient donc 4 tableaux de 4 poids.</p>
<p>Pour Wo, on a 2 neurones dans la couche de sortie. Donc on a 2 tableaux. Ces 2 tableaux contiennent les 4 poids de la couche cach√©e.</p>
<br/>
<h1 id="propagation-des-donn√©es">Propagation des donn√©es</h1>
<p>Les donn√©es d&rsquo;input sont propag√©es dans le r√©seau de neurones.
Pour propager les donn√©es de la couche d&rsquo;entr√©e vers la couche de sortie, il faut r√©aliser une succession de calculs de couche en couche et de neurone en neurone. Ces calculs sont simples car ce ne sont que des multiplications et des additions. Par contre, il faut en faire beaucoup. Nous n&rsquo;allons pas d√©tailler les calculs car cela n&rsquo;a pas d&rsquo;int√©r√™t et c&rsquo;est fastidieux. On va plut√¥t utiliser des matrices et faire des produits matriciels&hellip;</p>
<p>Nous allons commencer par cr√©er notre fonction sigmo√Øde qui permettra de calculer la valeur de sortie des neurones.</p>
<pre tabindex="0"><code>const sigmoid = (x) =&gt; {
    return 1 / (1 + Math.pow(Math.E, (-1 * x)));
}
</code></pre><p>En programmation, si on veut connecter deux couches de neurones (par exemple connecter la couche A avec la couche B), voici le pseudo-code:</p>
<pre tabindex="0"><code>Pour chaque neurone de la couche B:
    Pour chaque neurone de la couche A:
        Calcul sur le lien Wba;
    Fin pour;
Fin pour;
</code></pre><p>En JavaScript, cela donne:</p>
<pre tabindex="0"><code>for (let j = 0; j &lt; B.length; j++) {
    for (let i = 0; j &lt; A.length; i++) {
        // Calcul sur le lien w[j][i]
    }
}
</code></pre><p>Apr√®s ces quelques explications, nous allons cr√©er une fonction de propagation des donn√©es de la couche d&rsquo;entr√©e vers la couche de sortie. Cette fonction va appliquer la fonction d&rsquo;activation sur les sommes pond√©r√©es calcul√©es entre les neurones des diff√©rentes couches. On va cr√©er une fonction appel√©e propagate().</p>
<pre tabindex="0"><code>const propagate = (d) =&gt; {

    // On copie les donn√©es dans la couche d&#39;entr√©e
    for (let i = 0; i &lt; input.length; i++) {
        input[i] = d[i];
    }

    // On propage dans la couche cach√©e
    // Xh contient les sommes cumul√©es pour la couche cach√©e
    Xh = [0, 0, 0, 0];
    for (let j = 0; j &lt; hidden.length; j++) {
        for (let i = 0; i &lt; input.length; i++) {
            Xh[j] += Wh[j][i] * input[i];
        }   
    }

    // On applique la fonction d&#39;activation
    for (let j = 0; j &lt; hidden.length; j++) {
        hidden[j] = sigmoid(Xh[j]);
    }

    // On propage dans la couche de sortie
    // Xo contient les sommes pond√©r√©es de chaque neurone de sortie
    Xo = [0, 0];
    for (let k = 0; k &lt; output.length; k++) {
        for (let j = 0; j &lt; hidden.length; j++) {
            Xo[k] += Wo[k][j] * hidden[j];
        }
    }

    // On applique la fonction d&#39;activation
    for (let k = 0; k &lt; output.length; k++) {
        output[k] = sigmoid(Xo[k]);
    }
    
}
</code></pre><br/>
<h1 id="test-de-la-propagation">Test de la propagation</h1>
<p>On va cr√©er une petite interface en HTML permettant de visualiser la propagation. Si la valeur des 2 neurones de la derni√®re couche ont une valeur diff√©rente de [0, 0] (valeur d&rsquo;initialisation), c&rsquo;est que la propagation des donn√©es s&rsquo;est bien produite.</p>
<iframe  src='//jsfiddle.net/oeeckhoutte/440La2wz/32/embedded/result/dark/' allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>
<br/>
<h1 id="apprentissage">Apprentissage</h1>
<p>Nous allons passer √† la phase la plus importante qui est l&rsquo;apprentissage.
Cette phase est indispensable pour que notre r√©seau puisse apprendre √† reconna√Ætre nos images. Nous allons cr√©er une fonction learn() qui impl√©mente <a href="https://fr.wikipedia.org/wiki/R%C3%A9tropropagation_du_gradient">l&rsquo;algorithme de r√©tropropagation du gradient de l&rsquo;erreur</a>.</p>
<p>On va commencer par cr√©er 2 nouvelles variables qui vont nous servir √† d√©finir le taux d&rsquo;apprentissage et √† d√©finir la cible que l&rsquo;on souhaite obtenir en sortie du r√©seau de neurones.</p>
<ul>
<li>Le taux d&rsquo;apprentissage va √™tre initialis√© √† 0.5 et sera repr√©sent√© par la variable <strong>alpha</strong>.</li>
<li>La cible est un tableau de 2 valeurs. Il va √™tre initialis√© √† [0, 0] et s&rsquo;appelera <strong>target</strong>. Il s&rsquo;agit de la cible √† atteindre pour nos neurones de sortie.</li>
</ul>
<pre tabindex="0"><code>let alpha = 0.5;
let target = [0, 0];
</code></pre><p>Nous allons passer √† l&rsquo;impl√©mentation de l&rsquo;algorithme de r√©tropropagation du gradient de l&rsquo;erreur.
Pour notre exemple, cet algorithme comporte 4 √©tapes qui sont ex√©cut√©es les unes √† la suite des autres de mani√®re cyclique. La boucle s&rsquo;arr√™te lorsqu&rsquo;un crit√®re d&rsquo;arr√™t est atteint. On consid√®re donc que l&rsquo;apprentissage est termin√©.
Le crit√®re d&rsquo;arr√™t peut √™tre soit un seuil d&rsquo;erreur atteint ou soit un nombre d&rsquo;it√©rations maximum atteint.</p>
<p>Les 4 √©tapes de l&rsquo;algorithme sont les suivantes:</p>
<ul>
<li>Calcul de l&rsquo;erreur en sortie de la propagation des donn√©es.</li>
<li>Calcul des gradients d&rsquo;erreurs pour corriger les poids synaptiques des neurones de la couche de sortie.</li>
</ul>
<blockquote>
<p>Voici la formule que nous coderons qui permet de calculer l&rsquo;erreur propag√©e:
<img src="https://leandeep.com/images/derivee-partielle.png" alt="image"></p>
</blockquote>
<ul>
<li>Calcul des gradients d&rsquo;erreurs pour corriger les poids synaptiques des neurones de la couche cach√©e.</li>
<li>Mise √† jour des poids synaptiques de la couche de sortie et de la couche cach√©e</li>
</ul>
<p>Ci dessous, le code JavaScript qui impl√©mente cet algorithme:</p>
<pre tabindex="0"><code>
const learn = () =&gt; {

    // 1√®re √©tage:
    // On calcule l&#39;erreur sur les neurones de sortie
    let error = [];

    for (let k = 0; k &lt; output.length; k++) {
        error[k] = target[k] - output[k]
    }
    
    // 2√®me √©tage:
    // Calcul des gradients d&#39;erreurs de la couche de sortie
    let gradErrOutput = [[0, 0, 0, 0], [0, 0, 0, 0]];
    for (let k = 0; k &lt; output.length; k++) {
        for (let j = 0; j &lt; hidden.length; j++) {
            gradErrOutput[k][j] = -error[k] * output[k] * ( 1 - output[k]) * hidden[j];
        }
    }
    
    // 3√®me √©tage:
    // a. 
    // On retropropage l&#39;erreur de sortie vers les neurones de la couche cach√©e proportionnellement √† leurs poids synaptiques
    // b.
    // Ensuite on calcule les gradients d&#39;erreurs dans la couche cach√©e
    let gradErrHidden = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (let j = 0; j &lt; hidden.length; j++) {
        for (let i = 0; i &lt; input.length; i++) {
            // Variable locale permettant de cumuler l&#39;erreur proportionnellement aux poids synaptiques
            let e = 0;
            for (k = 0; k &lt; output.length; k++) {
                // Rappel: 
                // Wo contient les poids synaptiques associ√©s aux connexions entre la 2√®me et 3√®me couches
                e += Wo[k][j] * error[k];
                gradErrHidden[j][i] = -e * hidden[j] * (1 - hidden[j]) * input[i];
            }
        }
    }
    
    // 4√®me √©tape:
    // Mise √† jour de l&#39;ensemble des poids synaptiques. Pour chaque poids, on soustrait une portion du gradient d&#39;erreur par application du taux d&#39;apprentissage alpha.
    for (let k = 0; k &lt; output.length; k++) {
        for (let j = 0; j &lt; hidden.length; j++) {
            Wo[k][j] -= alpha * gradErrOutput[k][j];
        }
    }
    
    for (let j = 0; j &lt; hidden.length; j++) {
        for (let i = 0; i &lt; input.length; i++) {
            Wh[j][i] -= alpha * gradErrHidden[j][i];
        }
    }
}
</code></pre><br/>
<h1 id="test-de-la-r√©tropropagation">Test de la r√©tropropagation</h1>
<p>Nous allons modifier l&rsquo;interface que nous avons pr√©c√©demment cod√©e afin de tester le bon fonctionnement de notre algorithme.</p>
<p>Tout le code est accessible ci-dessous:</p>
<iframe  src='//jsfiddle.net/oeeckhoutte/bxt2wy25/72/embedded/js,html,result/dark/' allowpaymentrequest allowfullscreen="allowfullscreen" frameborder="0"></iframe>
<p>Si vous appuyez une dizaine de fois sur les boutons <strong>Propagate</strong> et <strong>Learn</strong> alternativement, vous verrez que le r√©seau de neurones fonctionne bien. Les erreurs diminuent et les valeurs en output convergent bien vers [1, 0].</p>
<p><img src="https://leandeep.com/images/front-propagation-neuronal-net.png" alt="image"></p>
<br/>
<h1 id="conclusion">Conclusion</h1>
<p>Si vous prenez le temps de bien lire cet article et de recoder l&rsquo;ensemble du r√©seau de neurones, vous comprendrez comment ils fonctionnent. Bien comprendre ces r√©seaux simples est indispensable pour aller plus loin et faire du <em>Deep Learning</em>.
L&rsquo;impl√©mentation de notre r√©seau pour notre exemple simple √©tait trivial. Par contre, en pratique, les use cases sont beaucoup plus complexes et donc cela se corse rapidement car l&rsquo;algorithme de r√©tropropagation du gradient de l&rsquo;erreur est sensible aux conditions de son ex√©cution. Il faudra faire attention au surapprentissage (<em>overfitting</em>) et √† la disparition du gradient (<em>vanishing gradient</em>) en jouant sur les fonctions d&rsquo;activation, le taux d&rsquo;apprentissage, pr√©-traiter les donn√©es d&rsquo;entr√©e en les normalisant par exemple&hellip;</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://leandeep.com/tags/machine-learning">Machine Learning</a></span><span class="tag"><a href="https://leandeep.com/tags/javascript">Javascript</a></span>
                </p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>2141 Mots</p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>03 juin. 2017</p>
        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h"></span>
                    <hr />
                </div>

                <div class="pagination__buttons">
                    
                        <span class="button previous">
                            <a href="https://leandeep.com/installer-miniconda-sur-osx/">
                                <span class="button__icon">‚Üê</span>
                                <span class="button__text">Installer (Mini)Conda sur OSX</span>
                            </a>
                        </span>
                    

                    
                        <span class="button next">
                            <a href="https://leandeep.com/pourquoi-il-faut-utiliser-object.is-pour-comparer-des-%C3%A9l%C3%A9ments/">
                                <span class="button__text">Pourquoi il faut utiliser Object.is() pour comparer des √©l√©ments</span>
                                <span class="button__icon">‚Üí</span>
                            </a>
                        </span>
                    
                </div>
            </div>
        

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>Built by <a href="https://www.linkedin.com/in/oliviereeckhoutte/">Olivier Eeckhoutte</a>,
                Freelance @ LeanDeep <a href="https://leandeep.com/about/">(üçÉ company)</a></span>
            <span>Siret: 83825337500011</span>
            <span><a href="https://leandeep.com/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss">
                        <path d="M4 11a9 9 0 0 1 9 9"></path>
                        <path d="M4 4a16 16 0 0 1 16 16"></path>
                        <circle cx="5" cy="19" r="1"></circle>
                    </svg></a></span>
        </div>
    </div>
</footer>
            
        </div>

        




<script type="text/javascript" src="https://leandeep.com/bundle.min.c184f8481b5847ad1a7d8aa775944fa063f118cb4df68f4eaa3826a2a2e16b26a1ad798f5160210f265c6fbb9a5f19b953fed066ae1ed1092d1858bcff13ae92.js" integrity="sha512-wYT4SBtYR60afYqndZRPoGPxGMtN9o9OqjgmoqLhayahrXmPUWAhDyZcb7uaXxm5U/7QZq4e0QktGFi8/xOukg=="></script>







    </body>
</html>
